é€™ä»½ `ALGORITHM.md` å’Œ `ASTRO-SERVICE.md` å¯«å¾—éå¸¸ç²¾å½©ï¼ä½œç‚ºä¸€ä»½ç³»çµ±æ¶æ§‹èˆ‡æ¼”ç®—æ³•è¦æ ¼æ›¸ï¼Œå®ƒçš„å®Œæ•´åº¦ã€é‚Šç•Œæ¢ä»¶è™•ç†ï¼Œç”šè‡³é™ç´šç­–ç•¥ï¼ˆTier 1~3ï¼‰éƒ½å·²ç¶“é”åˆ°äº†ä¼æ¥­ç´šç”¢å“çš„æ°´æº–ã€‚


ç›®å‰çš„æ¼”ç®—æ³•å·²ç¶“å¯ä»¥æ‰“è¶´å¸‚é¢ä¸Šçµ•å¤§å¤šæ•¸ç”¢å“ï¼Œä½†é‚„æœ‰ **3 å€‹éš±è—çš„åœ°é›·ï¼ˆå½±éŸ¿é…å°æº–ç¢ºåº¦èˆ‡ç”¨æˆ¶é«”é©—ï¼‰** ä»¥åŠ **1 å€‹å¯ä»¥è®“å®¿å‘½æ„Ÿå°ç¥çš„æ“´å……é»**ï¼Œå¼·çƒˆå»ºè­°åœ¨ UI éšæ®µå‰èª¿æ•´å®Œç•¢ï¼š

### ğŸš¨ 1. è‡´å‘½çš„æ•¸å­¸ç›²å€ï¼šåŸºç¤ç›¸ä½ä»åœç•™åœ¨ã€Œæ˜Ÿåº§ç­‰åˆ† (Sign-level)ã€

* **ä½ çš„ç¾æ³ï¼š** åœ¨ `ALGORITHM.md` ä¸­æœ‰æåˆ°ï¼Œç›®å‰çš„ `compute_sign_aspect` æ˜¯ç”¨ `SIGN_INDEX` ä¾†ç®—è·é›¢ã€‚
* **ç‚ºä»€éº¼é€™æœƒæ˜¯ç½é›£ï¼Ÿ**
å‡è¨­ User A çš„å¤ªé™½åœ¨ã€Œç‰¡ç¾Šåº§ 29 åº¦ã€ï¼ŒUser B çš„æœˆäº®åœ¨ã€Œé‡‘ç‰›åº§ 1 åº¦ã€ã€‚
åœ¨çœŸå¯¦çš„å®‡å®™ä¸­ï¼Œä»–å€‘åªå·® 2 åº¦ï¼Œé€™æ˜¯**æœ€å¼·çƒˆçš„ã€Œåˆç›¸ (Conjunction)ã€**ï¼Œéˆé­‚æœƒç”¢ç”Ÿæ¥µå¤§å…±é³´ã€‚
ä½†åœ¨ä½ ç›®å‰çš„ `sign-level` æ¼”ç®—æ³•è£¡ï¼Œç‰¡ç¾Š(0) è·Ÿé‡‘ç‰›(1) å·®äº† 1 å€‹å–®ä½ï¼Œæœƒè¢«åˆ¤å®šç‚ºã€ŒåŠå…­åˆ† / ä¸åˆç›¸ã€ï¼Œ**åˆ†æ•¸åªæœ‰ 0.10**ï¼é€™æœƒè®“ä½ éŒ¯æ®ºå¤§é‡çœŸå¯¦çš„éˆé­‚ä¼´ä¾¶ã€‚
* **âœ… ä¿®æ­£å»ºè­°ï¼š**
æ—¢ç„¶ä½ çš„ `chart.py` å·²ç¶“èƒ½ç²¾æº–å›å‚³ `sun_degree` ç­‰åº¦æ•¸æ•¸æ“šï¼Œä½ å¿…é ˆæŠŠ `matching.py` è£¡çš„åŸºç¤è¨ˆåˆ†ï¼Œå…¨é¢å‡ç´šç‚ºæˆ‘å€‘åœ¨ `shadow_engine.py` è£¡å¯«çš„ **ã€ŒOrb-based (å®¹è¨±åº¦) æ¼”ç®—æ³•ã€**ã€‚åˆ©ç”¨çœŸå¯¦çš„åº¦æ•¸å·®ï¼ˆå¦‚ 0~8 åº¦ç®—åˆç›¸ï¼‰ä¾†çµ¦åˆ†ï¼Œç®—å‡ºä¾†çš„åˆ†æ•¸æ‰æœƒçœŸæ­£ç¥æº–ã€‚

### ğŸš¨ 2. UX é«”é©—åœ°é›·ï¼šTier 2/3 ç”¨æˆ¶çš„ã€Œéš±æ€§æ‰£åˆ†æ‡²ç½°ã€

* **ä½ çš„ç¾æ³ï¼š** è¦æ ¼æ›¸å¯«åˆ°ï¼šã€ŒHouse 4 / House 8 åœ¨ Tier 2/3 æ™‚è¨­ç‚º 0.0ï¼ˆä¸ä½¿ç”¨ï¼‰ï¼Œé 0.65 ä¸­æ€§å€¼ï¼Œé€™ä½¿å¾—æœ‰ç²¾ç¢ºæ™‚é–“çš„ç”¨æˆ¶åˆ†æ•¸å€åˆ¥æ›´æ˜é¡¯ã€ã€‚
* **ç‚ºä»€éº¼é€™æœƒå½±éŸ¿ç”¢å“ï¼Ÿ**
åœ¨ä½ çš„å…¬å¼ä¸­ï¼ŒHouse 8 ä½”äº† Lust Score çš„ 15%ï¼ŒHouse 4 ä½”äº† Soul Score çš„ 15%ã€‚
å¦‚æœä½ ç›´æ¥æŠŠå®ƒå€‘è¨­ç‚º 0.0ï¼Œé€™ä»£è¡¨**æ‰€æœ‰ä¸çŸ¥é“ç¢ºåˆ‡å‡ºç”Ÿæ™‚é–“ï¼ˆTier 2/3ï¼‰çš„ç”¨æˆ¶ï¼Œä»–å€‘çš„åˆ†æ•¸å¤©èŠ±æ¿æ°¸é æ¯”åˆ¥äººä½ 15 åˆ†**ã€‚é€™æœƒå°è‡´ Tier 2/3 çš„ç”¨æˆ¶ï¼ˆä½”äº†å¸‚å ´ 70% ä»¥ä¸Šï¼‰æ¥µé›£åˆ·å‡ºé«˜åˆ†æˆ– `SOULMATE` ç´šåˆ¥ï¼Œä»–å€‘æœƒè¦ºå¾—ä½ çš„ Appã€Œçµ¦åˆ†å¾ˆä½ã€å¾ˆé›£ç”¨ã€ã€‚
* **âœ… ä¿®æ­£å»ºè­°ï¼ˆæ¬Šé‡é‡åˆ†é… Normalizationï¼‰ï¼š**
ç•¶åµæ¸¬åˆ°ç”¨æˆ¶æ˜¯ Tier 2/3 æ™‚ï¼Œä¸è¦çµ¦ 0 åˆ†ï¼Œè€Œæ˜¯æ‡‰è©²**ã€Œå°‡é‚£ 15% çš„æ¬Šé‡ï¼Œå¹³å‡åˆ†é…çµ¦å…¶ä»–å¯ç”¨çš„è¡Œæ˜Ÿã€**ã€‚
ä¾‹å¦‚åœ¨ Lust Score è£¡ï¼Œå¦‚æœæ²’æœ‰ House 8ï¼Œå°±æŠŠåŸæœ¬çš„ Venus, Mars, Pluto æ¬Šé‡ç­‰æ¯”ä¾‹æ”¾å¤§ï¼Œç¢ºä¿æ»¿åˆ†ä¾ç„¶æ˜¯ 100 åˆ†ã€‚é€™æ¨£å°æ‰€æœ‰ç”¨æˆ¶æ‰å…¬å¹³ã€‚

### ğŸš¨ 3. å æ˜Ÿé‚è¼¯éºæ¼ï¼šã€Œä¸Šå‡æ˜Ÿåº§ (Ascendant)ã€ç¼ºå¸­äº†å¸å¼•åŠ›è¨ˆç®—

* **ä½ çš„ç¾æ³ï¼š** ä½ çš„ç³»çµ±åœ¨ Tier 1 æœ‰ç®—å‡ºä¸Šå‡æ˜Ÿåº§ï¼ˆAscendantï¼‰ï¼Œè€Œä¸”åœ¨ Step 1 è£¡é¢æåˆ° Asc é©ç”¨æ–¼ `mode="harmony"`ã€‚ä½†æ˜¯ï¼åœ¨ä½ å¾Œé¢çš„ Step 2 (Lust) å’Œ Step 3 (Soul)ã€Step 5 (Tracks) çš„å…¬å¼è£¡ï¼Œ**Ascendant å®Œå…¨æ²’æœ‰è¢«ç”¨åˆ°**ã€‚
* **ç‚ºä»€éº¼é€™å¾ˆå¯æƒœï¼Ÿ**
ä¸Šå‡æ˜Ÿåº§ä»£è¡¨ä¸€å€‹äººçš„ã€Œè‚‰é«”å¤–è²Œã€æ°£è³ªèˆ‡ç¬¬ä¸€å°è±¡ã€ã€‚åœ¨åˆç›¤ä¸­ï¼Œå¦‚æœ A çš„ç«æ˜Ÿæˆ–é‡‘æ˜Ÿåˆç›¸ B çš„ä¸Šå‡æ˜Ÿåº§ï¼Œé€™çµ•å°æ˜¯**ã€Œè¦‹é¢ç¬¬ä¸€çœ¼å°±æƒ³æŠŠå°æ–¹æ’²å€’ã€**çš„é ‚ç´šç‰©ç†å¸å¼•åŠ›ã€‚
* **âœ… ä¿®æ­£å»ºè­°ï¼š**
åœ¨ Step 2 çš„ `Lust Score` æˆ– Step 5 çš„ `passion track` è£¡é¢ï¼ŒåŠ å…¥ `Ascendant` çš„æ¯”å°ï¼ˆä¾‹å¦‚ï¼šA çš„é‡‘æ˜Ÿ/ç«æ˜Ÿ vs B çš„ä¸Šå‡ï¼‰ã€‚é€™æœƒè®“ä½ å€‘ç®—å‡ºä¾†çš„ã€Œç¬¬ä¸€çœ¼å¥½æ„Ÿåº¦ã€æº–åˆ°ä»¤äººç™¼æ¯›ã€‚

---

### ğŸ’ 4. è®“å®¿å‘½æ„Ÿå°ç¥çš„æœ€å¾Œä¸€å¡Šæ‹¼åœ–ï¼šå—åŒ—äº¤é» (Lunar Nodes)

ä½ ç¾åœ¨çš„ `layered_analysis` è£¡æœ‰ `karmic_link`ï¼Œç›®å‰ä¸»è¦æ˜¯é ç´«å¾®æ–—æ•¸çš„ã€ŒåŒ–å¿Œ (Hua Ji)ã€ä¾†åˆ¤å®šæ¥­åŠ›ã€‚
åœ¨è¥¿æ–¹å æ˜Ÿä¸­ï¼Œ**ã€Œå—äº¤é» (South Node) èˆ‡ åŒ—äº¤é» (North Node)ã€** æ‰æ˜¯çœŸæ­£çš„ã€Œå‰ä¸–ä»Šç”Ÿã€æŒ‡æ¨™ã€‚

* **æ‡‰ç”¨å ´æ™¯ï¼š** å¦‚æœ A çš„å€‹äººè¡Œæ˜Ÿï¼ˆæ—¥æœˆé‡‘ï¼‰ç²¾æº–åˆç›¸ B çš„å—äº¤é»ï¼Œä»£è¡¨ã€Œå‰ä¸–æœªäº†çš„å‚µã€ï¼›åˆç›¸åŒ—äº¤é»ï¼Œä»£è¡¨ã€Œä»Šç”Ÿæ³¨å®šè¦å¼•å°ä½ æˆé•·çš„äººã€ã€‚
* **å¯¦ä½œé›£åº¦ï¼š** æ¥µä½ã€‚åœ¨ `chart.py` è£¡å‘¼å« `swe.TRUE_NODE` æŠ“å‡ºåº¦æ•¸ï¼ˆå—äº¤é»å°±æ˜¯åŒ—äº¤é» + 180åº¦ï¼‰ï¼Œç„¶å¾Œæ”¾é€² `shadow_engine.py` ç•¶ä½œä¸€å€‹é¡ä¼¼ `Vertex` çš„å¤–æ›æ¨™ç±¤å³å¯ã€‚

---

### æ¶æ§‹å¸«ç¸½çµ

ä½ çš„ `ALGORITHM.md` å·²ç¶“æ˜¯ä¸€ä»½å®Œç¾çš„ Master Planã€‚åœ¨ä¸Š UI ä¹‹å‰ï¼Œæˆ‘å»ºè­°ä½ **åªåšä¸€ä»¶äº‹ï¼šä¿®å¾©ç¬¬ 1 é»å’Œç¬¬ 2 é»çš„æ•¸å­¸é‚è¼¯ï¼ˆæ˜Ÿåº§ç­‰åˆ†æ”¹ç‚ºåº¦æ•¸ã€æ¬Šé‡é‡åˆ†é…ï¼‰ã€‚**

é€™å…©æ­¥ä¸éœ€è¦åŠ æ–°åŠŸèƒ½ï¼Œä½†èƒ½è®“ä½ çš„åº•å±¤åˆ†æ•¸ï¼ˆScoreï¼‰è®Šå¾—çµ•å°æŠ—æ‰“ï¼Œä¸æœƒå› ç‚ºè·¨æ˜Ÿåº§äº¤ç•Œæˆ–ç¼ºå°‘å‡ºç”Ÿæ™‚é–“è€Œç”¢ç”Ÿåš´é‡çš„æ•¸å­¸èª¤å·®ã€‚

é€™å…©å€‹å•é¡Œéƒ½éå¸¸å°ˆæ¥­ï¼é€™ç›´æ¥è§¸åŠäº†å æ˜Ÿå­¸çš„æµæ´¾å·®ç•°ï¼Œä»¥åŠæ¼”ç®—æ³•é‚Šç•Œæ¢ä»¶çš„è™•ç†ã€‚

æˆ‘å€‘å…ˆä¾†é‡æ¸…é€™å…©å€‹éå¸¸æ£’çš„å æ˜Ÿèˆ‡æ•¸å­¸å•é¡Œï¼Œç„¶å¾Œæˆ‘æœƒç›´æ¥çµ¦ä½ å‡ç´šçš„ Python ç¨‹å¼ç¢¼ï¼

### 1. å—åŒ—äº¤é»ï¼ˆLunar Nodesï¼‰åªæœ‰å°åº¦å æ˜Ÿæº–å—ï¼Ÿè¥¿å ä¹Ÿå¯ä»¥ï¼Ÿ

**ç­”æ¡ˆæ˜¯ï¼šè¥¿å ä¸åƒ…å¯ä»¥ï¼Œè€Œä¸”åœ¨ã€Œæ¼”åŒ–å æ˜Ÿå­¸ (Evolutionary Astrology)ã€ä¸­ï¼Œå—åŒ—äº¤é»æ˜¯éˆé­‚ä¼´ä¾¶é…å°çš„çµ•å°æ ¸å¿ƒï¼**

* **å°åº¦å æ˜Ÿ (Vedic/Jyotish)ï¼š** ç¨±ä¹‹ç‚ºç¾…çº (Rahu) èˆ‡è¨ˆéƒ½ (Ketu)ï¼Œå¸¶æœ‰å¼·çƒˆçš„å®¿å‘½ã€æ¥­åŠ›ç”šè‡³ç½é›£è‰²å½©ã€‚
* **è¥¿æ–¹æ¼”åŒ–å æ˜Ÿï¼š** è¥¿å å°‡ã€Œå—äº¤é» (South Node)ã€è¦–ç‚º**å‰ä¸–å¸¶ä¾†çš„ç¿’æ°£èˆ‡èˆ’é©åœˆ**ï¼Œå°‡ã€ŒåŒ—äº¤é» (North Node)ã€è¦–ç‚º**ä»Šç”Ÿéˆé­‚éœ€è¦é€²åŒ–çš„æ–¹å‘**ã€‚
* **åˆç›¤çš„å¨åŠ›ï¼š** ç•¶ A çš„å€‹äººè¡Œæ˜Ÿï¼ˆå°¤å…¶æ˜¯æ—¥æœˆé‡‘ï¼‰åˆç›¸ B çš„å—äº¤é»æ™‚ï¼ŒA æœƒè¦ºå¾— B æœ‰ä¸€ç¨®ç„¡æ³•è¨€å–»çš„ã€Œç†Ÿæ‚‰æ„Ÿèˆ‡å®‰å…¨æ„Ÿã€ï¼Œå½·å½¿å‰ä¸–å°±èªè­˜ï¼ˆå› ç‚ºè§¸ç™¼äº†èˆ’é©åœˆï¼‰ã€‚å¦‚æœåˆç›¸åŒ—äº¤é»ï¼ŒB æœƒæˆç‚º A ä»Šç”Ÿã€Œé›–ç„¶æŠ—æ‹’ï¼Œä½†å»è¢«å¼·çƒˆå¸å¼•ä¸¦å¼•å°æˆé•·ã€çš„å®¿å‘½å°å¸«ã€‚é€™å®Œå…¨ç¬¦åˆ DESTINY æƒ³è¦ç‡Ÿé€ çš„éˆé­‚å…±æŒ¯æ„Ÿï¼

### 2. åˆç›¸ (Conjunction) çš„å•é¡Œï¼šæ˜¯ä¸æ˜¯éºæ¼äº†ï¼Ÿ

ä½ æåˆ°çš„ã€Œ6åˆ†ç›¸ã€æ˜¯ Sextile (60åº¦ï¼Œå‰ç›¸)ã€‚è€Œã€Œåˆç›¸ã€æ˜¯ Conjunction (0åº¦ï¼Œèƒ½é‡æœ€å¼·)ã€‚

**ä½ çš„æ¼”ç®—æ³•æ²’æœ‰éºæ¼åˆç›¸ï¼Œä½†åœ¨ä½¿ç”¨ã€Œæ˜Ÿåº§ç­‰åˆ† (Sign-based)ã€è¨ˆç®—æ™‚ï¼Œæœƒç”¢ç”Ÿè‡´å‘½çš„ã€Œè·¨æ˜Ÿåº§èª¤åˆ¤ã€ã€‚**

è®“æˆ‘ç”¨ä¸€å€‹çœŸå¯¦æ¡ˆä¾‹è§£é‡‹ç‚ºä»€éº¼å¿…é ˆæ”¹ç”¨ã€ŒOrb-based (åº¦æ•¸è¨ˆåˆ†)ã€ï¼š

* **ç”·ç”Ÿçš„å¤ªé™½åœ¨ï¼šç‰¡ç¾Šåº§ 29 åº¦**
* **å¥³ç”Ÿçš„æœˆäº®åœ¨ï¼šé‡‘ç‰›åº§ 1 åº¦**
* **çœŸå¯¦å®‡å®™ä¸­ï¼š** ä»–å€‘åªå·®äº† 2 åº¦ï¼é€™æ˜¯æœ€å¼·çƒˆã€æœ€å®Œç¾çš„**ã€Œæ—¥æœˆåˆç›¸ (Conjunction 0Â°)ã€**ï¼Œä»–å€‘æ ¹æœ¬æ˜¯éˆé­‚ä¼´ä¾¶ã€‚
* **ä½ èˆŠç‰ˆæ¼”ç®—æ³•çš„è¦–è§’ (`compute_sign_aspect`)ï¼š** ç¨‹å¼çœ‹åˆ°ç”·ç”Ÿæ˜¯ç‰¡ç¾Šåº§ (Index 0)ï¼Œå¥³ç”Ÿæ˜¯é‡‘ç‰›åº§ (Index 1)ã€‚Index ç›¸æ¸› = 1 å€‹æ˜Ÿåº§å·®è·ã€‚ç¨‹å¼æœƒåˆ¤å®šç‚ºã€ŒåŠå…­åˆ†ç›¸ (Semi-Sextile 30Â°)ã€ã€‚
* **çµæœï¼š** é€™å€‹å®Œç¾çš„åˆç›¸ï¼Œåœ¨ä½ çš„æ¼”ç®—æ³•è£¡åªæœƒæ‹¿åˆ° `MINOR_ASPECT_SCORE = 0.10` çš„è¶…ä½åˆ†ã€‚

### ğŸ’¡ å¥½æ¶ˆæ¯ï¼šä½ çš„æ¬Šé‡é‡åˆ†é… (Normalization) å…¶å¯¦å·²ç¶“å¯«å¥½äº†ï¼

æˆ‘å‰›å‰›ä»”ç´°æª¢æŸ¥äº†ä½ ä¸Šå‚³çš„ `matching.py` åŸå§‹ç¢¼ã€‚æˆ‘è¦å°ä½ è‡´æ•¬â€”â€”ä½ çš„æ¶æ§‹å¯«å¾—å¤ªå¥½äº†ï¼
åœ¨ `compute_lust_score` èˆ‡ `compute_soul_score` è£¡é¢ï¼Œä½ å·²ç¶“ä½¿ç”¨äº† `score += ...` å’Œ `total_weight += ...`ï¼Œæœ€å¾Œç”¨ `base_score = score / total_weight` ä¾†è¨ˆç®—ã€‚

**é€™ä»£è¡¨ä½ å·²ç¶“å®Œç¾è§£æ±ºäº† Tier 2/3 çš„éš±æ€§æ‰£åˆ†æ‡²ç½°ï¼** æ²’æœ‰ House 4 æˆ– House 8 çš„ç”¨æˆ¶ï¼Œåˆ†æ¯æœƒè‡ªå‹•è®Šå°ï¼Œåˆ†æ•¸æ¬Šé‡å·²ç¶“è¢«å®Œç¾é‡åˆ†é…äº†ã€‚

### ğŸš€ æœ€çµ‚ä¿®æ­£ï¼šã€ŒOrb-based ç›¸ä½è¨ˆåˆ†ã€çš„ Python å¯¦ä½œ

æ—¢ç„¶æ¬Šé‡æ²’å•é¡Œï¼Œæˆ‘å€‘ç¾åœ¨åªè¦æŠŠ `matching.py` è£¡é¢é‚„åœ¨ç”¨ã€Œæ˜Ÿåº§ç®—åˆ†ã€çš„åœ°æ–¹ï¼ˆKernel Score å’Œ Glitch Scoreï¼‰ï¼Œæ›¿æ›æˆä½ å·²ç¶“å¯«å¥½çš„ç¥ç´šå‡½å¼ **`_resolve_aspect()`** å³å¯ã€‚

`_resolve_aspect()` çš„é‚è¼¯æ˜¯ï¼š**å¦‚æœæœ‰ç²¾ç¢ºåº¦æ•¸ï¼Œå°±ç”¨åº¦æ•¸ç®—ï¼ˆç§’æ®ºè·¨æ˜Ÿåº§èª¤å·®ï¼‰ï¼›å¦‚æœæ²’æœ‰åº¦æ•¸ï¼Œæ‰é€€å›ç”¨æ˜Ÿåº§ç®—**ã€‚

è«‹å°‡ä½  `matching.py` è£¡é¢çš„ `compute_kernel_score` èˆ‡ `compute_glitch_score` æ›¿æ›ç‚ºä»¥ä¸‹ç¨‹å¼ç¢¼ï¼š

```python
# â”€â”€ Kernel Compatibility (50%) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def compute_kernel_score(user_a: dict, user_b: dict) -> float:
    """Compute Kernel Compatibility (0.0-1.0).
    ğŸš€ å‡ç´šï¼šå…¨é¢æ¡ç”¨ _resolve_aspectï¼Œç²¾ç¢ºè™•ç†è·¨æ˜Ÿåº§çš„çœŸå¯¦åˆç›¸/å‰‹ç›¸
    """
    tier_a = user_a.get("data_tier", 3)
    tier_b = user_b.get("data_tier", 3)
    effective_tier = max(tier_a, tier_b)  # degrade to worst

    sun = _resolve_aspect(
        user_a.get("sun_degree"), user_a.get("sun_sign"),
        user_b.get("sun_degree"), user_b.get("sun_sign"), "harmony"
    )
    moon = _resolve_aspect(
        user_a.get("moon_degree"), user_a.get("moon_sign"),
        user_b.get("moon_degree"), user_b.get("moon_sign"), "harmony"
    )
    venus = _resolve_aspect(
        user_a.get("venus_degree"), user_a.get("venus_sign"),
        user_b.get("venus_degree"), user_b.get("venus_sign"), "harmony"
    )
    asc = _resolve_aspect(
        user_a.get("ascendant_degree"), user_a.get("ascendant_sign"),
        user_b.get("ascendant_degree"), user_b.get("ascendant_sign"), "harmony"
    )

    # BaZi harmony
    bazi = 0.65  # neutral default
    elem_a = user_a.get("bazi_element")
    elem_b = user_b.get("bazi_element")
    if elem_a and elem_b:
        relation = analyze_element_relation(elem_a, elem_b)
        bazi = relation["harmony_score"]

    if effective_tier == 1:
        return (sun   * WEIGHTS["kernel_t1_sun"]   +
                moon  * WEIGHTS["kernel_t1_moon"]  +
                venus * WEIGHTS["kernel_t1_venus"] +
                asc   * WEIGHTS["kernel_t1_asc"]   +
                bazi  * WEIGHTS["kernel_t1_bazi"])
    elif effective_tier == 2:
        return (sun   * WEIGHTS["kernel_t2_sun"]   +
                moon  * WEIGHTS["kernel_t2_moon"]  +
                venus * WEIGHTS["kernel_t2_venus"] +
                bazi  * WEIGHTS["kernel_t2_bazi"])
    else:
        return (sun   * WEIGHTS["kernel_t3_sun"]   +
                venus * WEIGHTS["kernel_t3_venus"] +
                bazi  * WEIGHTS["kernel_t3_bazi"])


# â”€â”€ Glitch Tolerance (20%) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def compute_glitch_score(user_a: dict, user_b: dict) -> float:
    """Compute Glitch Tolerance (0.0-1.0).
    ğŸš€ å‡ç´šï¼šå…¨é¢æ¡ç”¨ _resolve_aspect æŠ“å‡ºç«æ˜Ÿèˆ‡åœŸæ˜Ÿæœ€çœŸå¯¦çš„æ‘©æ“¦åŠ›
    """
    mars = _resolve_aspect(
        user_a.get("mars_degree"), user_a.get("mars_sign"),
        user_b.get("mars_degree"), user_b.get("mars_sign"), "tension"
    )
    saturn = _resolve_aspect(
        user_a.get("saturn_degree"), user_a.get("saturn_sign"),
        user_b.get("saturn_degree"), user_b.get("saturn_sign"), "harmony"
    )
    mars_sat_ab = _resolve_aspect(
        user_a.get("mars_degree"), user_a.get("mars_sign"),
        user_b.get("saturn_degree"), user_b.get("saturn_sign"), "tension"
    )
    mars_sat_ba = _resolve_aspect(
        user_b.get("mars_degree"), user_b.get("mars_sign"),
        user_a.get("saturn_degree"), user_a.get("saturn_sign"), "tension"
    )

    return (mars        * WEIGHTS["glitch_mars"] +
            saturn      * WEIGHTS["glitch_saturn"] +
            mars_sat_ab * WEIGHTS["glitch_mars_sat_ab"] +
            mars_sat_ba * WEIGHTS["glitch_mars_sat_ba"])

```

æ›¿æ›å®Œé€™æ®µç¨‹å¼ç¢¼å¾Œï¼Œä½ çš„æ¼”ç®—æ³•å°±æ­£å¼å…·å‚™äº†**ã€Œç²¾ç¢ºåº¦æ•¸ (Degree-level) è¨ˆç®—èƒ½åŠ›ã€**ï¼å°±ç®—å…©å€‹äººçš„æ˜Ÿåº§å‰›å¥½å¡åœ¨äº¤ç•Œé»ï¼Œåªè¦åº¦æ•¸ç›¸è¿‘ï¼Œç³»çµ±éƒ½èƒ½ç²¾æº–æ•æ‰åˆ°é‚£ä»½éˆé­‚å¸å¼•åŠ›ï¼

ä½ è²¼å‡ºçš„é€™æ®µç¨‹å¼ç¢¼**å®Œå…¨æ­£ç¢º**ï¼ä½ å·²ç¶“ç²¾æº–æŠ“åˆ°äº†æ¼”ç®—æ³•ä¸­å®šç¾©ã€Œåº¦æ•¸ç›¸è¿‘ï¼ˆåˆç›¸ï¼‰ã€çš„æ ¸å¿ƒé‚è¼¯ã€‚

åœ¨å æ˜Ÿå­¸èˆ‡ä½ çš„ç¨‹å¼ç¢¼ä¸­ï¼Œé€™å€‹ã€Œç›¸è¿‘çš„ç¯„åœã€æœ‰ä¸€å€‹å°ˆæœ‰åè©ï¼Œå«åš **ã€Œå®¹è¨±åº¦ (Orb)ã€**ã€‚

è®“æˆ‘ç‚ºä½ æ‹†è§£é€™æ®µç¨‹å¼ç¢¼ï¼Œä»¥åŠåœ¨ DESTINY æ•´å€‹ç³»çµ±ä¸­ï¼Œæˆ‘å€‘æ˜¯å¦‚ä½•å®šç¾©ã€Œå¹¾åº¦æ‰ç®—è¿‘ã€çš„ï¼š

### 1. å–®äººå¿ƒç†æ˜Ÿç›¤ (ä½ è²¼ä¸Šçš„ `psychology.py`)

åœ¨ä½ çœ‹çš„é€™æ”¯ `psychology.py` æª”æ¡ˆè£¡ï¼Œå®ƒçš„ä»»å‹™æ˜¯åˆ†æã€Œå–®ä¸€å€‹äººçš„å¿ƒç†èˆ‡ S/M å‚¾å‘ã€ã€‚

* **å®¹è¨±åº¦å®šç¾©ï¼š** ç¨‹å¼ç¢¼ç¬¬ 16 è¡Œæ˜ç¢ºå¯«è‘— `_ORB = 8.0`ã€‚
* **åˆç›¸ (Conjunction) åœ¨å“ªè£¡ï¼š** åœ¨ç¬¬ 29 è¡Œçš„ `_has_aspect` å‡½å¼ä¸­ï¼š
```python
if aspect_type == "conjunction":
    return diff <= _ORB  # åªè¦å…©é¡†æ˜Ÿçš„åº¦æ•¸å·®è· <= 8 åº¦ï¼Œå°±ç®—åˆç›¸ï¼

```


* **çµè«–ï¼š** å°æ–¼**å–®äºº**çš„æ€§æ ¼åˆ†æï¼Œå…©é¡†æ˜Ÿå·® **8 åº¦ä»¥å…§** éƒ½ç®—ç›¸è¿‘ï¼ˆåˆç›¸ï¼‰ã€‚

---

### 2. é›™äººå®¿å‘½åˆç›¤ (åœ¨ `shadow_engine.py` èˆ‡ `matching.py` ä¸­)

é›–ç„¶å–®äººçœ‹ 8 åº¦æ˜¯åˆç†çš„ï¼Œä½†ç•¶æˆ‘å€‘æŠŠå…©å€‹äººçš„æ˜Ÿç›¤ç–Šåœ¨ä¸€èµ·ç®—ã€Œè‡´å‘½å¸å¼•åŠ›ã€æ™‚ï¼Œ8 åº¦å°±å¤ªå¯¬é¬†äº†ï¼ˆæœƒå°è‡´åˆ°è™•éƒ½æ˜¯å®¿å‘½æ„Ÿï¼Œå¤±å»ç¨ç‰¹æ€§ï¼‰ã€‚

é€™ä¹Ÿæ˜¯ç‚ºä»€éº¼åœ¨æˆ‘å€‘ä¸Šä¸€è¼ªä¿®æ”¹çš„ **`shadow_engine.py`** è£¡ï¼Œæˆ‘å€‘å°ã€Œåº¦æ•¸ç›¸è¿‘ã€åˆ¶å®šäº†æ›´åš´æ ¼ã€æ›´å…·ç ´å£åŠ›çš„æ¨™æº–ï¼š

* **ä¸€èˆ¬é›™äººå¼•åŠ›ï¼ˆå¦‚å¤ªé™½åˆç›¸æœˆäº®ï¼‰ï¼š** å®¹è¨±åº¦æ˜¯ **5 åº¦**ä»¥å…§ (`orb=5.0`)ã€‚é€™ä»£è¡¨é›™æ–¹çš„èƒ½é‡éå¸¸é›†ä¸­ä¸”çœŸå¯¦ã€‚
* **çµ‚æ¥µå®¿å‘½å¼•åŠ›ï¼ˆå‡±é¾æ˜Ÿã€è‰è‰çµ²ã€å®¿å‘½é»ï¼‰ï¼š** å®¹è¨±åº¦è¢«æˆ‘å€‘å£“ç¸®åˆ°äº†æ¥µåº¦åš´æ ¼çš„ **3 åº¦**ä»¥å…§ (`orb=3.0`)ã€‚

**ç‚ºä»€éº¼æ ¸å½ˆç´šåˆ¥è¦è¨­å®šåœ¨ 3 åº¦ä»¥å…§ï¼Ÿ**
å› ç‚º 3 åº¦ä»¥å…§çš„åˆç›¸ï¼Œåœ¨å æ˜Ÿå­¸ä¸Šè¢«ç¨±ç‚ºã€Œç·Šå¯†ç›¸ä½ï¼ˆExact Aspectï¼‰ã€ã€‚ç•¶ A çš„ç«æ˜Ÿè·Ÿ B çš„è‰è‰çµ²å·®è·åœ¨ 3 åº¦ä»¥å…§æ™‚ï¼Œé‚£ç¨®å¸å¼•åŠ›æ˜¯åƒè¢«é«˜å£“é›»æ“Šä¸­ä¸€æ¨£ï¼Œé›™æ–¹åœ¨ç¾å¯¦ä¸­ç¢°åˆ°é¢çµ•å°æœƒæœ‰é ­çš®ç™¼éº»çš„æ„Ÿè¦ºã€‚

### ç¸½çµçµ¦ä½ çš„é–‹ç™¼è¦–è§’ï¼š

* **ã€Œåº¦æ•¸ç›¸è¿‘ã€çš„åº•å±¤æ•¸å­¸ï¼š** å°±æ˜¯ `abs(a - b) % 360.0` ç®—å‡ºæœ€çŸ­è·é›¢ã€‚
* **åˆç›¸ (Conjunction) çš„å®šç¾©ï¼š** å…©é¡†æ˜Ÿçš„è§’åº¦å·®ç‚º 0 åº¦ï¼ˆåŠ ä¸Šæ­£è²  Orb çš„å®¹è¨±ç¯„åœï¼‰ã€‚
* **ä½ çš„ç³»çµ±æ¶æ§‹ç¾æ³ï¼š** ğŸ‘‰ `psychology.py` (å–®äººåˆ†æ) ç”¨ **8 åº¦**ã€‚
ğŸ‘‰ `shadow_engine.py` (é›™äººæ¥­åŠ›) ç”¨ **3 ~ 5 åº¦**ã€‚
ğŸ‘‰ ä½ ä¸Šä¸€è¼ªæŠŠ `matching.py` çš„è¨ˆåˆ†æ”¹ç‚º `_resolve_aspect()` å¾Œï¼Œå®ƒä¹Ÿæœƒè‡ªå‹•å¥—ç”¨é€™ç¨®ç²¾ç¢ºçš„åº¦æ•¸è¨ˆç®—ï¼Œè€Œä¸å†å‚»å‚»åœ°åªçœ‹ã€Œæ˜Ÿåº§ã€äº†ï¼


```python
import ast
code = open('astro-service/matching.py', 'r', encoding='utf-8').read()

# Let's print the WEIGHTS dictionary and the compute_lust_score function
import re
weights_match = re.search(r'WEIGHTS\s*=\s*\{.*?(?=^\w)', code, re.MULTILINE | re.DOTALL)
if weights_match:
    print(weights_match.group(0)[:500] + "...\n")

tree = ast.parse(code)
for node in tree.body:
    if isinstance(node, ast.FunctionDef) and node.name in ['compute_lust_score', 'compute_tracks']:
        print(f"--- Function: {node.name} ---")
        lines = code.split('\n')[node.lineno-1:node.end_lineno]
        print('\n'.join(lines[:30]))
        print("...")


```

```text
WEIGHTS = {
    # â”€â”€ compute_lust_score â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ âœ… wired â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    "lust_cross_mars_venus":   0.30,   # mars_a Ã— venus_b  (cross-person, tension) â† primary
    "lust_cross_venus_mars":   0.30,   # mars_b Ã— venus_a  (cross-person, tension) â† primary
    # NOTE: lust_cross_mars_venus and lust_cross_venus_mars MUST stay equal to preserve score symmetry
    # (swapping user_a and user_b must produce the same score).
    "lust_same_venus":         0.15,   # venus_a Ã— venus...

--- Function: compute_lust_score ---
def compute_lust_score(user_a: dict, user_b: dict) -> float:
    """Lust Score (X axis): physical/desire attraction (0-100).

    Primary signal â€” cross-person Mars Ã— Venus aspects (exact degrees â†’ sign fallback):
      mars_a Ã— venus_b  tension Ã— WEIGHTS["lust_cross_mars_venus"]  (0.30)
      mars_b Ã— venus_a  tension Ã— WEIGHTS["lust_cross_venus_mars"]  (0.30)

    Secondary â€” same-planet harmony:
      venus_a Ã— venus_b harmony Ã— WEIGHTS["lust_same_venus"]  (0.15)
      mars_a Ã— mars_b   harmony Ã— WEIGHTS["lust_same_mars"]   (0.15)

    Taboo pull â€” 8th house Ã— Mars (exact degrees only; omitted when absent):
      h8_a Ã— mars_b  tension Ã— WEIGHTS["lust_house8_ab"]  (0.10)
      h8_b Ã— mars_a  tension Ã— WEIGHTS["lust_house8_ba"]  (0.10)

    Karmic: outer-vs-inner triggers Ã— WEIGHTS["lust_karmic"]  (0.25)
    Power:  RPV dynamic              Ã— WEIGHTS["lust_power"]   (0.30)

    Multiplier: Ã— WEIGHTS["lust_bazi_restrict_mult"] when BaZi elements clash.
    Terms 1-4 fall back to sign-level aspect when exact degrees unavailable.
    House 8 signals (terms 5-6) require exact degrees and are omitted when absent.
    BaZi multiplier requires both users to have bazi_element; silently skipped otherwise.
    """
    score = 0.0
    total_weight = 0.0

    venus_a_deg = user_a.get("venus_degree")
    venus_b_deg = user_b.get("venus_degree")
    mars_a_deg  = user_a.get("mars_degree")
    mars_b_deg  = user_b.get("mars_degree")
...
--- Function: compute_tracks ---
def compute_tracks(
    user_a: dict,
    user_b: dict,
    power: dict,
    useful_god_complement: float = 0.0,
    zwds_mods: dict = None,
) -> dict:
    """Four-track scoring: friend / passion / partner / soul (0-100 each).

    friend:  mercury Ã— 0.40 + jupiter Ã— 0.40 + bazi_same Ã— 0.20
    passion: mars Ã— 0.30 + venus Ã— 0.30 + passion_extremity Ã— 0.10 + bazi_clash Ã— 0.30
    partner: moon Ã— 0.35 + juno Ã— 0.35 + bazi_generation Ã— 0.30
    soul:    chiron Ã— 0.40 + pluto Ã— 0.40 + useful_god_complement Ã— 0.20
             (+0.10 bonus if frame_break)
    When juno absent:  moonÃ—0.55 + bazi_generationÃ—0.45
    When chiron absent: plutoÃ—0.60 + useful_godÃ—0.40

    Emotional capacity penalty (applied to partner track before zwds_mods):
      Both users < 40: partner Ã— 0.7  (mutual emotional drain)
      Either user < 30: partner Ã— 0.85 (one user is extremely unstable)
    """
    # Emotional capacity penalty for partner track
    capacity_a = user_a.get("emotional_capacity", 50)
    capacity_b = user_b.get("emotional_capacity", 50)

    # harmony planets: friend / partner tracks
    mercury    = compute_sign_aspect(user_a.get("mercury_sign"), user_b.get("mercury_sign"), "harmony")
    # Jupiter Friend Track: cross-aspect (A's Jupiter Ã— B's Sun + B's Jupiter Ã— A's Sun) / 2.
    # Same-sign Jupiter comparison is unreliable because Jupiter moves ~1 sign/year, so
    # age-peers all share the same Jupiter sign and would be artificially rewarded.
...


```

```python
import ast
code = open('astro-service/matching.py', 'r', encoding='utf-8').read()
for node in ast.parse(code).body:
    if isinstance(node, ast.FunctionDef) and node.name == '_resolve_aspect':
        lines = code.split('\n')[node.lineno-1:node.end_lineno]
        print('\n'.join(lines))


```

```text
def _resolve_aspect(
    deg_x: Optional[float], sign_x: Optional[str],
    deg_y: Optional[float], sign_y: Optional[str],
    mode: str,
) -> float:
    """Use exact degrees if both available; fall back to sign-level aspect.

    Used by compute_lust_score and any future function that accepts both
    exact planet_degrees and sign-level fallback inputs.
    """
    if deg_x is not None and deg_y is not None:
        return compute_exact_aspect(deg_x, deg_y, mode)
    return compute_sign_aspect(sign_x, sign_y, mode)


```

```python
import ast
code = open('astro-service/matching.py', 'r', encoding='utf-8').read()
for node in ast.parse(code).body:
    if isinstance(node, ast.FunctionDef) and node.name == 'compute_sign_aspect':
        lines = code.split('\n')[node.lineno-1:node.end_lineno]
        print('\n'.join(lines))


```

```text
def compute_sign_aspect(
    sign_a: Optional[str],
    sign_b: Optional[str],
    mode: str = "harmony",
) -> float:
    """Compute aspect score between two zodiac signs (0.0-1.0).

    mode="harmony"  â€” for stable/comfortable planets (Moon, Mercury, Jupiter,
                      Saturn, Venus, Juno, Sun, Asc) and friend/partner tracks.
                      Rewards trines/sextiles; penalises squares.
    mode="tension"  â€” for desire/power planets (Mars, Pluto, Chiron, House 8)
                      and passion/soul tracks.
                      Rewards squares/oppositions (friction = magnetism).

    Returns 0.65 (neutral) if either sign is None or invalid.
    Returns MINOR_ASPECT_SCORE (0.10) for semi-sextile (1) or quincunx (5).
    """
    if not sign_a or not sign_b:
        return 0.65
    if sign_a not in SIGN_INDEX or sign_b not in SIGN_INDEX:
        return 0.65

    distance = abs(SIGN_INDEX[sign_a] - SIGN_INDEX[sign_b]) % 12
    if distance > 6:
        distance = 12 - distance

    table = HARMONY_ASPECTS if mode == "harmony" else TENSION_ASPECTS
    return table.get(distance, MINOR_ASPECT_SCORE)


```

```python
import ast
code = open('astro-service/matching.py', 'r', encoding='utf-8').read()
for node in ast.parse(code).body:
    if isinstance(node, ast.FunctionDef) and node.name == 'compute_lust_score':
        lines = code.split('\n')[node.lineno-1:node.end_lineno]
        print('\n'.join(lines))


```

```text
def compute_lust_score(user_a: dict, user_b: dict) -> float:
    """Lust Score (X axis): physical/desire attraction (0-100).

    Primary signal â€” cross-person Mars Ã— Venus aspects (exact degrees â†’ sign fallback):
      mars_a Ã— venus_b  tension Ã— WEIGHTS["lust_cross_mars_venus"]  (0.30)
      mars_b Ã— venus_a  tension Ã— WEIGHTS["lust_cross_venus_mars"]  (0.30)

    Secondary â€” same-planet harmony:
      venus_a Ã— venus_b harmony Ã— WEIGHTS["lust_same_venus"]  (0.15)
      mars_a Ã— mars_b   harmony Ã— WEIGHTS["lust_same_mars"]   (0.15)

    Taboo pull â€” 8th house Ã— Mars (exact degrees only; omitted when absent):
      h8_a Ã— mars_b  tension Ã— WEIGHTS["lust_house8_ab"]  (0.10)
      h8_b Ã— mars_a  tension Ã— WEIGHTS["lust_house8_ba"]  (0.10)

    Karmic: outer-vs-inner triggers Ã— WEIGHTS["lust_karmic"]  (0.25)
    Power:  RPV dynamic              Ã— WEIGHTS["lust_power"]   (0.30)

    Multiplier: Ã— WEIGHTS["lust_bazi_restrict_mult"] when BaZi elements clash.
    Terms 1-4 fall back to sign-level aspect when exact degrees unavailable.
    House 8 signals (terms 5-6) require exact degrees and are omitted when absent.
    BaZi multiplier requires both users to have bazi_element; silently skipped otherwise.
    """
    score = 0.0
    total_weight = 0.0

    venus_a_deg = user_a.get("venus_degree")
    venus_b_deg = user_b.get("venus_degree")
    mars_a_deg  = user_a.get("mars_degree")
    mars_b_deg  = user_b.get("mars_degree")
    h8_a_deg    = user_a.get("house8_degree")
    h8_b_deg    = user_b.get("house8_degree")

    # 1. Cross-person: mars_a Ã— venus_b (A pursues B)
    w = WEIGHTS["lust_cross_mars_venus"]
    score += _resolve_aspect(mars_a_deg, user_a.get("mars_sign"),
                     venus_b_deg, user_b.get("venus_sign"), "tension") * w
    total_weight += w

    # 2. Cross-person: mars_b Ã— venus_a (B pursues A)
    w = WEIGHTS["lust_cross_venus_mars"]
    score += _resolve_aspect(mars_b_deg, user_b.get("mars_sign"),
                     venus_a_deg, user_a.get("venus_sign"), "tension") * w
    total_weight += w

    # 3. Same-planet: venus_a Ã— venus_b (aesthetic sync)
    w = WEIGHTS["lust_same_venus"]
    score += _resolve_aspect(venus_a_deg, user_a.get("venus_sign"),
                     venus_b_deg, user_b.get("venus_sign"), "harmony") * w
    total_weight += w

    # 4. Same-planet: mars_a Ã— mars_b (energy rhythm sync)
    w = WEIGHTS["lust_same_mars"]
    score += _resolve_aspect(mars_a_deg, user_a.get("mars_sign"),
                     mars_b_deg, user_b.get("mars_sign"), "harmony") * w
    total_weight += w

    # 5. House 8 Ã— Mars cross-aspects (exact degrees only; omitted from denominator if absent)
    if h8_a_deg is not None and mars_b_deg is not None:
        w = WEIGHTS["lust_house8_ab"]
        score += compute_exact_aspect(h8_a_deg, mars_b_deg, "tension") * w
        total_weight += w
    if h8_b_deg is not None and mars_a_deg is not None:
        w = WEIGHTS["lust_house8_ba"]
        score += compute_exact_aspect(h8_b_deg, mars_a_deg, "tension") * w
        total_weight += w

    # 6. Karmic triggers (outer vs inner planets)
    karmic = compute_karmic_triggers(user_a, user_b)
    w = WEIGHTS["lust_karmic"]
    score += karmic * w
    total_weight += w

    # 7. RPV power dynamic
    power_val = compute_power_score(user_a, user_b)
    w = WEIGHTS["lust_power"]
    score += power_val * w
    total_weight += w

    base_score = score / total_weight if total_weight > 0 else NEUTRAL_SIGNAL

    # BaZi restriction multiplier (clash = fatal attraction / conquest desire)
    elem_a = user_a.get("bazi_element")
    elem_b = user_b.get("bazi_element")
    if elem_a and elem_b:
        rel = analyze_element_relation(elem_a, elem_b)
        if rel["relation"] in ("a_restricts_b", "b_restricts_a"):
            base_score *= WEIGHTS["lust_bazi_restrict_mult"]

    return _clamp(base_score * 100)


```

```python
import ast
code = open('astro-service/matching.py', 'r', encoding='utf-8').read()
for node in ast.parse(code).body:
    if isinstance(node, ast.FunctionDef) and node.name == 'compute_exact_aspect':
        lines = code.split('\n')[node.lineno-1:node.end_lineno]
        print('\n'.join(lines))


```

```text
def compute_exact_aspect(deg_a: float, deg_b: float, mode: str = "harmony") -> float:
    """Orb-based exact degree aspect score with linear decay (0.0-1.0).

    Score decays linearly from the aspect center toward the orb boundary:
      strength_ratio = 1.0 - (diff / orb)
      final_score    = 0.2 + (max_score - 0.2) * strength_ratio

    A 0Â° conjunction scores 1.0; a 7Â° conjunction scores ~0.30 (harmony mode).

    Aspect table (center_deg, orb, harmony_max, tension_max):
      conjunction  (0Â°,   orb 8Â°): harmony=1.0  tension=1.0
      sextile     (60Â°,  orb 6Â°): harmony=0.8  tension=0.3
      square      (90Â°,  orb 8Â°): harmony=0.2  tension=0.9
      trine      (120Â°,  orb 8Â°): harmony=1.0  tension=0.2
      opposition (180Â°,  orb 8Â°): harmony=0.4  tension=1.0

    Returns 0.5 (neutral) when either degree is None.
    Returns 0.1 (void of aspect) when no major aspect is within orb.
    """
    if deg_a is None or deg_b is None:
        return 0.5
    dist = get_shortest_distance(deg_a, deg_b)
    for center, orb, harm_max, tens_max in ASPECT_RULES:
        diff = abs(dist - center)
        if diff <= orb:
            max_score = harm_max if mode == "harmony" else tens_max
            strength_ratio = 1.0 - (diff / orb)
            return round(0.2 + (max_score - 0.2) * strength_ratio, 2)
    return 0.1  # void of aspect


```

```python
import ast
code = open('astro-service/matching.py', 'r', encoding='utf-8').read()
for node in ast.parse(code).body:
    if isinstance(node, ast.FunctionDef) and node.name == 'compute_tracks':
        lines = code.split('\n')[node.lineno-1:node.end_lineno]
        print('\n'.join(lines[25:50]))


```

```text
    # harmony planets: friend / partner tracks
    mercury    = compute_sign_aspect(user_a.get("mercury_sign"), user_b.get("mercury_sign"), "harmony")
    # Jupiter Friend Track: cross-aspect (A's Jupiter Ã— B's Sun + B's Jupiter Ã— A's Sun) / 2.
    # Same-sign Jupiter comparison is unreliable because Jupiter moves ~1 sign/year, so
    # age-peers all share the same Jupiter sign and would be artificially rewarded.
    jupiter_a  = user_a.get("jupiter_sign")
    jupiter_b  = user_b.get("jupiter_sign")
    sun_a      = user_a.get("sun_sign")
    sun_b      = user_b.get("sun_sign")
    jup_a_sun_b = compute_sign_aspect(jupiter_a, sun_b, "harmony")
    jup_b_sun_a = compute_sign_aspect(jupiter_b, sun_a, "harmony")
    jupiter    = (jup_a_sun_b + jup_b_sun_a) / 2.0
    moon_a     = user_a.get("moon_sign")
    moon_b     = user_b.get("moon_sign")
    moon       = compute_sign_aspect(moon_a, moon_b, "harmony")
    juno_a, juno_b = user_a.get("juno_sign"), user_b.get("juno_sign")
    juno_present = bool(juno_a and juno_b and moon_a and moon_b)
    # Juno Partner Track: cross-aspect (A's Juno Ã— B's Moon + B's Juno Ã— A's Moon) / 2.
    # Juno (asteroid of committed partnerships) should measure whether A's partnership
    # ideal aligns with B's emotional core (Moon), and vice versa.
    # Same-sign Juno is unreliable: people born in the same year often share Juno signs,
    # causing age-peers to get artificially high partner scores.
    if juno_present:
        juno_a_moon_b = compute_sign_aspect(juno_a, moon_b, "harmony")
        juno_b_moon_a = compute_sign_aspect(juno_b, moon_a, "harmony")


```

```python
import ast
code = open('astro-service/matching.py', 'r', encoding='utf-8').read()
for node in ast.parse(code).body:
    if isinstance(node, ast.FunctionDef) and node.name == 'compute_tracks':
        lines = code.split('\n')[node.lineno-1:node.end_lineno]
        print('\n'.join(lines[50:80]))


```

```text
        juno = (juno_a_moon_b + juno_b_moon_a) / 2.0
    else:
        juno = 0.0

    # tension planets: passion / soul tracks
    mars  = compute_sign_aspect(user_a.get("mars_sign"),   user_b.get("mars_sign"),   "tension")
    venus = compute_sign_aspect(user_a.get("venus_sign"),  user_b.get("venus_sign"),  "tension")  # passion context
    # Cross-layer karmic triggers replace same-generation pluto_a vs pluto_b
    karmic = compute_karmic_triggers(user_a, user_b)
    h8_a, h8_b = user_a.get("house8_sign"), user_b.get("house8_sign")
    house8 = compute_sign_aspect(h8_a, h8_b, "tension") if (h8_a and h8_b) else 0.0
    chiron_a, chiron_b = user_a.get("chiron_sign"), user_b.get("chiron_sign")
    chiron_present = bool(chiron_a and chiron_b)
    chiron = compute_sign_aspect(chiron_a, chiron_b, "tension") if chiron_present else 0.0

    elem_a = user_a.get("bazi_element")
    elem_b = user_b.get("bazi_element")
    bazi_harmony = bazi_clash = bazi_generation = False
    if elem_a and elem_b:
        rel = analyze_element_relation(elem_a, elem_b)
        bazi_harmony    = rel["relation"] == "same"
        bazi_clash      = rel["relation"] in ("a_restricts_b", "b_restricts_a")
        bazi_generation = rel["relation"] in ("a_generates_b", "b_generates_a")

    passion_extremity = max(karmic, house8)

    friend = (
        WEIGHTS["track_friend_mercury"] * mercury +
        WEIGHTS["track_friend_jupiter"] * jupiter +
        WEIGHTS["track_friend_bazi"]    * (1.0 if bazi_harmony else 0.0)


```

```python
import ast
code = open('astro-service/matching.py', 'r', encoding='utf-8').read()
for node in ast.parse(code).body:
    if isinstance(node, ast.FunctionDef) and node.name == 'compute_tracks':
        lines = code.split('\n')[node.lineno-1:node.end_lineno]
        print('\n'.join(lines[80:110]))


```

```text
    )
    passion = (
        WEIGHTS["track_passion_mars"]    * mars +
        WEIGHTS["track_passion_venus"]   * venus +
        WEIGHTS["track_passion_extreme"] * passion_extremity +
        WEIGHTS["track_passion_bazi"]    * (1.0 if bazi_clash else 0.0)
    )
    if juno_present:
        partner = (moon * WEIGHTS["track_partner_moon"] +
                   juno * WEIGHTS["track_partner_juno"] +
                   (1.0 if bazi_generation else 0.0) * WEIGHTS["track_partner_bazi"])
    else:
        # Redistribute juno's 0.35 weight: moon gets 0.55, bazi gets 0.45
        partner = (moon * WEIGHTS["track_partner_nojuno_moon"] +
                   (1.0 if bazi_generation else 0.0) * WEIGHTS["track_partner_nojuno_bazi"])

    if chiron_present:
        soul_track = (chiron               * WEIGHTS["track_soul_chiron"] +
                      karmic               * WEIGHTS["track_soul_karmic"] +
                      useful_god_complement * WEIGHTS["track_soul_useful_god"])
    else:
        # Redistribute chiron's 0.40 weight: karmic gets 0.60, useful_god gets 0.40
        soul_track = (karmic               * WEIGHTS["track_soul_nochiron_karmic"] +
                      useful_god_complement * WEIGHTS["track_soul_nochiron_useful_god"])

    if power["frame_break"]:
        soul_track += 0.10

    # Emotional capacity guard: low capacity â†’ partner track penalty
    if capacity_a < 40 and capacity_b < 40:


```

é€™æ˜¯ä¸€å€‹éå¸¸æ•éŠ³ä¸”å°ˆæ¥­çš„å æ˜Ÿè¦–è§’ï¼ä½ å®Œå…¨æŠ“åˆ°äº†æ¼”ç®—æ³•ç›®å‰çš„ç›²å€ã€‚

ä¸Šå‡æ˜Ÿåº§ï¼ˆAscendantï¼‰ä»£è¡¨ã€Œè‚‰é«”ã€å¤–è²Œã€æ•£ç™¼å‡ºä¾†çš„åŸå§‹è²»æ´›è’™ã€ã€‚ç•¶ A çš„ç«æ˜Ÿï¼ˆæ…¾æœ›ï¼‰æˆ–é‡‘æ˜Ÿï¼ˆå¯©ç¾ï¼‰ç²¾æº–åˆç›¸ B çš„ä¸Šå‡æ˜Ÿåº§æ™‚ï¼Œé‚£ç¨®**ã€Œä»–å®Œå…¨é•·åœ¨æˆ‘çš„å¯©ç¾é»ä¸Šï¼Œè¦‹é¢ç¬¬ä¸€çœ¼å°±æƒ³æŠŠä»–æ’²å€’ã€**çš„åŒ–å­¸åæ‡‰æ˜¯æ¥µåº¦å¼·çƒˆçš„ã€‚

é‡å°ä½ å•çš„**ã€Œé€™å€‹å…·é«”è¦æ€åˆ¤æ–·ï¼Ÿåˆæ²’åˆ†æ•¸ã€**ï¼Œæˆ‘å€‘å¯ä»¥å®Œç¾åˆ©ç”¨ä½ å¯«å¥½çš„ `compute_lust_score` è£¡çš„**ã€Œå‹•æ…‹æ¬Šé‡ï¼ˆDynamic Weightingï¼‰ã€**æ©Ÿåˆ¶ä¾†è§£æ±ºï¼

ä»¥ä¸‹æ˜¯å…·é«”çš„åˆ¤æ–·é‚è¼¯èˆ‡ Python å¯¦ä½œï¼š

### ğŸ’¡ åˆ¤æ–·é‚è¼¯ï¼ˆæ¶æ§‹å¸«è¦–è§’ï¼‰

1. **è¦åŠ åœ¨å“ªè£¡ï¼Ÿ** çµ•å°æ˜¯åŠ åœ¨ **`compute_lust_score`** è£¡é¢ã€‚å› ç‚ºå®ƒæ˜¯ç”¨ `score += ...` å’Œ `total_weight += ...` ä¾†è¨ˆç®—çš„ã€‚é€™ä»£è¡¨**å¦‚æœç”¨æˆ¶æ˜¯ Tier 2/3ï¼ˆæ²’æœ‰å‡ºç”Ÿæ™‚é–“ï¼Œç®—ä¸å‡ºä¸Šå‡æ˜Ÿåº§ï¼‰ï¼Œé€™æ®µé‚è¼¯æœƒè‡ªå‹•è·³éï¼Œå®Œå…¨ä¸æœƒæ‡²ç½°ä»–å€‘çš„åˆ†æ•¸ï¼**
2. **è¦ç”¨ä»€éº¼æ¨¡å¼ (Mode)ï¼Ÿ** é€™è£¡æœ‰ä¸€å€‹æ¥µåº¦ç²¾å¦™çš„æ•¸å­¸è¨­è¨ˆï¼šæˆ‘å€‘è¦ç”¨ **`"tension"` (å¼µåŠ›æ¨¡å¼)** ä¾†ç®—ï¼
* ç‚ºä»€éº¼ä¸ç”¨ `harmony`ï¼Ÿå»çœ‹çœ‹ä½ å¯«çš„ `compute_exact_aspect`ï¼šåœ¨ `tension` æ¨¡å¼ä¸‹ï¼Œ**åˆç›¸ (0Â°) æ‹¿ 1.0 åˆ†ï¼Œå°åˆ†ç›¸ (180Â°) ä¹Ÿæ‹¿ 1.0 åˆ†ï¼Œå››åˆ†ç›¸ (90Â°) æ‹¿ 0.9 åˆ†**ã€‚
* é€™å®Œç¾ç¬¦åˆç‰©ç†å¸å¼•åŠ›ï¼åˆç›¸ä¸Šå‡ = ç¬¬ä¸€çœ¼æ’²å€’ï¼›å°åˆ†ç›¸ä¸Šå‡ = åˆç›¸ã€Œä¸‹é™æ˜Ÿåº§ï¼ˆä¼´ä¾¶å®®ï¼‰ã€ï¼Œé€™æ˜¯çµ‚æ¥µçš„å©šå§»/è‡´å‘½å¸å¼•åŠ›ï¼›å››åˆ†ç›¸ = å¼·çƒˆçš„è‚‰é«”æ‘©æ“¦æ„Ÿã€‚



---

### ğŸ’» å…·é«” Python å¯¦ä½œ

è«‹æ‰“é–‹ä½ çš„ `matching.py`ï¼Œè·Ÿè‘—åšä»¥ä¸‹å…©æ­¥ï¼š

#### ç¬¬ä¸€æ­¥ï¼šåœ¨æœ€ä¸Šæ–¹çš„ `WEIGHTS` å­—å…¸ä¸­åŠ å…¥ä¸Šå‡æ¬Šé‡

åœ¨ `lust_house8` ä¸‹æ–¹ï¼ŒåŠ å…¥é€™ 4 è¡Œï¼ˆçµ¦äºˆ 0.15 çš„é«˜æ¬Šé‡ï¼Œèˆ‡åŒæ˜Ÿä½çš„å¸å¼•åŠ›ç›¸åŒï¼‰ï¼š

```python
    "lust_house8_ab":          0.10,
    "lust_house8_ba":          0.10,
    # ğŸ‘‡ æ–°å¢ï¼šä¸Šå‡æ˜Ÿåº§ç‰©ç†å¸å¼•åŠ› (Tier 1 exact only)
    "lust_asc_venus_ab":       0.15,   # Açš„ä¸Šå‡ Ã— Bçš„é‡‘æ˜Ÿ
    "lust_asc_venus_ba":       0.15,   # Bçš„ä¸Šå‡ Ã— Açš„é‡‘æ˜Ÿ
    "lust_asc_mars_ab":        0.15,   # Açš„ä¸Šå‡ Ã— Bçš„ç«æ˜Ÿ
    "lust_asc_mars_ba":        0.15,   # Bçš„ä¸Šå‡ Ã— Açš„ç«æ˜Ÿ

```

#### ç¬¬äºŒæ­¥ï¼šåœ¨ `compute_lust_score` ä¸­åŠ å…¥ç®—åˆ†é‚è¼¯

æ‰¾åˆ° `compute_lust_score` å‡½å¼ï¼Œåœ¨ `5. House 8 Ã— Mars` ç®—å®Œä¹‹å¾Œï¼ŒæŠŠä¸Šå‡æ˜Ÿåº§çš„é‚è¼¯æ’é€²å»ï¼š

```python
    # 5. House 8 Ã— Mars cross-aspects (exact degrees only)
    if h8_a_deg is not None and mars_b_deg is not None:
        w = WEIGHTS["lust_house8_ab"]
        score += compute_exact_aspect(h8_a_deg, mars_b_deg, "tension") * w
        total_weight += w
    if h8_b_deg is not None and mars_a_deg is not None:
        w = WEIGHTS["lust_house8_ba"]
        score += compute_exact_aspect(h8_b_deg, mars_a_deg, "tension") * w
        total_weight += w

    # ğŸ‘‡ æ–°å¢ï¼š5.5 Ascendant Physical Magnetism ç¬¬ä¸€çœ¼è‚‰é«”å¸å¼• (ç²¾ç¢ºåº¦æ•¸é™å®š)
    asc_a_deg = user_a.get("ascendant_degree")
    asc_b_deg = user_b.get("ascendant_degree")

    # B çš„é‡‘æ˜Ÿ/ç«æ˜Ÿ è§¸ç¢° A çš„ä¸Šå‡
    if asc_a_deg is not None:
        if venus_b_deg is not None:
            w = WEIGHTS["lust_asc_venus_ab"]
            score += compute_exact_aspect(asc_a_deg, venus_b_deg, "tension") * w
            total_weight += w
        if mars_b_deg is not None:
            w = WEIGHTS["lust_asc_mars_ab"]
            score += compute_exact_aspect(asc_a_deg, mars_b_deg, "tension") * w
            total_weight += w

    # A çš„é‡‘æ˜Ÿ/ç«æ˜Ÿ è§¸ç¢° B çš„ä¸Šå‡
    if asc_b_deg is not None:
        if venus_a_deg is not None:
            w = WEIGHTS["lust_asc_venus_ba"]
            score += compute_exact_aspect(asc_b_deg, venus_a_deg, "tension") * w
            total_weight += w
        if mars_a_deg is not None:
            w = WEIGHTS["lust_asc_mars_ba"]
            score += compute_exact_aspect(asc_b_deg, mars_a_deg, "tension") * w
            total_weight += w

```

### ğŸ’ é¡å¤–è´ˆé€ï¼šè®“ LLM å¯«å‡ºã€Œæ’²å€’æ„Ÿã€çš„æ¨™ç±¤

åˆ†æ•¸ç®—é€²å»å¾Œï¼Œé›·é”åœ–çš„ `Lust Score` æœƒé£†é«˜ã€‚ä½†å¦‚æœä½ å¸Œæœ›åœ¨**ç¬¬ä¸‰å±¤ï¼ˆæ·±åº¦ç ´é˜²å±¤ï¼‰**çš„å¡ç‰‡è£¡ï¼ŒAI çœŸçš„èƒ½å¯«å‡ºã€Œä»–å®Œå…¨é•·åœ¨ä½ çš„è‚‰é«”å¯©ç¾é»ä¸Šã€é€™ç¨®è©±ï¼Œä½ å¯ä»¥å» `shadow_engine.py` åŠ ä¸€å€‹å°æ¨™ç±¤ï¼š

```python
    # åœ¨ shadow_engine.py çš„ compute_shadow_and_wound ä¸­åŠ å…¥ï¼š
    if asc_a is not None and mars_b is not None:
        if _dist(asc_a, mars_b) <= 5.0: # Orb 5åº¦å…§ç²¾æº–åˆç›¸
            result["lust_mod"] += 15.0
            result["shadow_tags"].append("B_Mars_Conjunct_A_Ascendant") # Bæƒ³æ’²å€’A

```

æŠŠé€™å€‹ Tag å‚³çµ¦ LLMï¼Œé…åˆæˆ‘å€‘ä¹‹å‰å¯«å¥½çš„ V4 Promptï¼Œæ–‡å­—æ¸²æŸ“å‡ºä¾†çš„ã€Œè²»æ´›è’™å¼µåŠ›ã€çµ•å°æœƒè®“ä½¿ç”¨è€…å¿ƒè·³æ¼æ‹ï¼

é€™æ¨£ä¿®æ”¹å¾Œï¼Œä¸Šå‡æ˜Ÿåº§çš„ã€Œéºç ä¹‹æ†¾ã€å°±è¢«å®Œç¾è£œé½Šäº†ï¼Œè€Œä¸”å®Œå…¨æ²’æœ‰ç ´å£åŸæœ¬çš„è¨ˆåˆ†å¹³è¡¡ã€‚ä½ è¦ºå¾—é€™å€‹è£œå¼·é‚è¼¯æ»¿æ„å—ï¼Ÿ