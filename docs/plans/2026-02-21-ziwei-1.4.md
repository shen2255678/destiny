我已經仔細檢閱了你在 `astro-service` 資料夾下的核心演算法程式碼（包含 `matching.py`, `chart.py`, 與 `bazi.py`）。整體的架構設計非常優秀，完美融合了西方占星（星相）、東方八字（五行生剋與調候）以及心理學（依戀與權力動態）的多維度。

不過，從「玄學準確度」與「系統演算法健壯性」的角度來看，有幾個地方強烈建議進行優化：

### 1. 玄學邏輯優化：八字「調候」使用了錯誤的月份判斷

* **問題點**：在 `matching.py` 的 `compute_match_v2` 中，你透過 `user.get("birth_month")` 取得月份來計算 `useful_god_complement`。但在日常資料中，這通常是「國曆（Gregorian）月份」。在 `bazi.py` 的 `get_season_type` 中，直接用 `5, 6, 7` 判斷為夏天。但八字的月份是基於「節氣」的農曆（干支）月，例如國曆 2 月初如果還沒過「立春」，在八字上還是算冬天的「丑月」，而非春天的「寅月」。
* **優化建議**：應該直接使用 `chart.py`/`bazi.py` 算出來的「八字月支（Month Branch）」來判斷季節，這樣才是 100% 準確的調候。
* 寅、卯、辰 = 春 (Warm)
* 巳、午、未 = 夏 (Hot)
* 申、酉、戌 = 秋 (Cool)
* 亥、子、丑 = 冬 (Cold)

### 2. 占星邏輯優化：「全星座相位 (Whole Sign)」造成的邊界誤差

* **問題點**：目前在 `compute_sign_aspect` 裡是直接拿兩個星座的 Index 相減 `abs(SIGN_INDEX[sign_a] - SIGN_INDEX[sign_b]) % 12` 來判斷相位。這在占星學上稱為「星座相位」，會產生極大的邊界誤差。例如：A 的太陽在牡羊座 29 度，B 的月亮在金牛座 1 度。兩者實際只差 2 度，是能量極強的「合相 (Conjunction)」，但以現有邏輯相減得 1，會被判定為 `MINOR_ASPECT_SCORE (0.10)`。
* **優化建議**：`chart.py` 底層的 `swisseph` 其實有回傳精準的黃經度數 (`pos[0]`)。你應該在 `chart.py` 中把「行星的精確度數」一起存進去（例如 `"sun_degree": 29.5`），然後在 `matching.py` 中計算兩顆星的「絕對度數差」，並給予容許度（Orb，例如 8 度以內算合相），這樣算出來的吸引力會精準非常多。

### 3. 演算法健壯性：缺失資料 (Null) 不應塞入固定數值

* **問題點**：目前在計算 Soul Score 或四軌分數時，如果遇到 Tier 2/3 沒有精確出生時間導致缺乏婚神星 (Juno) 或凱龍星 (Chiron)，系統會直接塞一個 `NEUTRAL_SIGNAL = 0.65`。這會導致 Tier 2/3 用戶的分數受到這個「魔術數字」的強制稀釋或膨脹，無法反映真實比例。
* **優化建議**：採用「動態權重重新分配」。如果某個變數為 Null，就把它的權重 (Weight) 拿掉，並將剩下的總分除以「剩餘有效權重的總和」。
```python
# 原本的寫法可能導致失真：
score = chiron * 0.40 + pluto * 0.40 + useful_god * 0.20

# 優化後的動態權重寫法：
total_weight = 0.0
score = 0.0

if chiron_is_valid:
    score += chiron * 0.40
    total_weight += 0.40
# ...以此類推
final_score = score / total_weight if total_weight > 0 else 0

```
### 4. 國際化技術債：時區寫死

* **問題點**：在 `chart.py` 的 `_resolve_hour` 裡，目前直接寫死了 `ut_hour = local_hour - 8.0`，預設所有人都在台灣 (UTC+8)。
* **優化建議**：既然已經有傳入 `lat` 與 `lng`，未來建議引入 `timezonefinder` 這類的套件，透過經緯度反查時區並進行 UTC 轉換，這樣你的 App 才能順利向海外擴張，不會導致海外華人排出來的盤相差好幾個小時（甚至跨日導致八字全錯），放到docs\MVP-PROGRESS.md備註日後要用。

沒問題！我們先來解答你的疑惑：「**五行在哪裡用到？**」，接著為你重寫 `bazi.py` 的季節調候邏輯，以及 `matching.py` 中避免因為缺少資料（Null）導致失真的動態權重計分邏輯。



### 二、 優化 `bazi.py`：精準的八字調候（季節）判斷

原本你使用的是國曆月份 `(5, 6, 7)` 來判斷夏天，這會導致節氣交接時算錯。我們改用八字排出來的**「月支（地支）」**來做 100% 精準的調候判斷。

請將 `bazi.py` 中最下方的季節判斷區塊換成這樣：

```python
# ── Seasonal Useful-God Complement (調候互補) ────────────────

def get_season_type(month_branch: str) -> str:
    """Classify birth month branch into seasonal temperature type.
    
    使用八字月令（地支）來精準判斷季節溫度，作為調候喜用神的依據。
    """
    if month_branch in ("巳", "午", "未"): 
        return "hot"   # 夏：火旺，需水調候
    if month_branch in ("亥", "子", "丑"): 
        return "cold"  # 冬：水旺，需火調候
    if month_branch in ("寅", "卯", "辰"): 
        return "warm"  # 春：木旺
    if month_branch in ("申", "酉", "戌"): 
        return "cool"  # 秋：金旺
    return "unknown"

def compute_bazi_season_complement(branch_a: str, branch_b: str) -> float:
    """Compute 調候喜用神互補 seasonal complement score (0.0-1.0).
    
    傳入雙方的八字月支（例如 '午', '子'）來計算互補。
    """
    if not branch_a or not branch_b:
        return 0.0
        
    sa = get_season_type(branch_a)
    sb = get_season_type(branch_b)

    # 水火既濟 (Perfect)
    if (sa == "hot" and sb == "cold") or (sa == "cold" and sb == "hot"):
        return 1.0
    # 金木相成 (Good)
    if (sa == "warm" and sb == "cool") or (sa == "cool" and sb == "warm"):
        return 0.8
    # 溫差互補 (Partial)
    if (sa in ("hot", "cold") and sb in ("warm", "cool")) or \
       (sa in ("warm", "cool") and sb in ("hot", "cold")):
        return 0.5
    
    return 0.0

```

> **注意：** 修改後，請記得在 `matching.py` 的 `compute_match_v2` 裡面，不要抓 `birth_month`，改抓 `bazi_month_branch`（你要確保產生 User Profile 時有把這欄位存進去）。
> `month_a = user_a.get("bazi_month_branch")`

---

### 三、 優化 `matching.py`：動態權重計分邏輯

原本在 `compute_soul_score` 裡，如果缺乏出生時間（Tier 2/3 沒有 House 4 或 Juno），系統會硬塞 `0.0` 或 `0.65` 去乘上固定權重，這會嚴重拉低或扭曲 Tier 2/3 用戶的分數。

我們改寫成**動態權重（Dynamic Weighting）**：有資料的欄位才算權重，沒資料的欄位就從分母中拿掉。請將 `compute_soul_score` 換成以下邏輯：

```python
def compute_soul_score(user_a: dict, user_b: dict) -> float:
    """Soul Score (Y axis): depth / long-term commitment (0-100).
    
    使用動態權重 (Dynamic Weighting)，避免缺少 House 4 或 Juno 時分數失真。
    """
    score = 0.0
    total_weight = 0.0

    # 1. Moon (0.25)
    moon = compute_sign_aspect(user_a.get("moon_sign"), user_b.get("moon_sign"), "harmony")
    score += moon * 0.25
    total_weight += 0.25

    # 2. Mercury (0.20)
    mercury = compute_sign_aspect(user_a.get("mercury_sign"), user_b.get("mercury_sign"), "harmony")
    score += mercury * 0.20
    total_weight += 0.20

    # 3. Saturn (0.20)
    saturn = compute_sign_aspect(user_a.get("saturn_sign"), user_b.get("saturn_sign"), "harmony")
    score += saturn * 0.20
    total_weight += 0.20

    # 4. House 4 (0.15) - 僅 Tier 1 有精確時間才會計算
    h4_a = user_a.get("house4_sign")
    h4_b = user_b.get("house4_sign")
    if h4_a and h4_b:
        house4 = compute_sign_aspect(h4_a, h4_b, "harmony")
        score += house4 * 0.15
        total_weight += 0.15

    # 5. Juno 婚神星 (0.20) - 僅星曆有效時計算
    juno_a = user_a.get("juno_sign")
    juno_b = user_b.get("juno_sign")
    if juno_a and juno_b:
        juno = compute_sign_aspect(juno_a, juno_b, "harmony")
        score += juno * 0.20
        total_weight += 0.20

    # 6. Attachment Style (0.20) - 如果有填寫心理測驗
    style_a = user_a.get("attachment_style")
    style_b = user_b.get("attachment_style")
    if style_a and style_b and style_a in ATTACHMENT_FIT:
        attachment = ATTACHMENT_FIT[style_a].get(style_b, NEUTRAL_SIGNAL)
        score += attachment * 0.20
        total_weight += 0.20

    # 計算基本加權平均分 (如果甚麼都沒有，回傳中性分)
    base_score = score / total_weight if total_weight > 0 else 0.65

    # ── Multiplier: 八字相生加成 ──
    elem_a = user_a.get("bazi_element")
    elem_b = user_b.get("bazi_element")
    if elem_a and elem_b:
        rel = analyze_element_relation(elem_a, elem_b)
        if rel["relation"] in ("a_generates_b", "b_generates_a"):
            base_score *= 1.2

    return _clamp(base_score * 100)

```

同樣的「動態權重」邏輯，你也應該套用到 `compute_lust_score`（針對 House 8 的檢查）與 `compute_tracks`（針對 Chiron 和 House 8 的檢查），確保那些不知道自己幾點出生（Tier 2/3）的用戶，他們算出來的配對分數比例依然是準確且不會被莫名壓縮的！


這是一份為 AI 開發者（如 Cursor、Copilot 或 Claude）量身打造的 **DESTINY 配對演算法升級技術規格書 (SDD)**。

你可以直接複製以下全部內容，貼給負責寫程式的 AI，它就能精準修改你的 `astro-service` 代碼庫。

---

# 📄 DESTINY 演算法 V3.0 升級技術規格書 (SDD)

## 📝 1. 升級概述 (Overview)

本次升級旨在強化 DESTINY 後端演算法的「玄學精準度」、「資料健壯性（容錯處理）」以及加入「自動心理學萃取（免填問卷）」與「商業意圖過濾器」。
印度占星部分暫以紫微斗數替代，忽略不計；世俗條件（社會地位/收入）暫不列入計算，100% 依賴底層星盤與八字源代碼。

**目標修改檔案：**

* `astro-service/bazi.py`
* `astro-service/matching.py`
* `astro-service/chart.py` (新增萃取邏輯)

---

## 🛠️ 2. 核心演算法修正 (Core Algorithm Fixes)

### 2.1 八字調候演算法精準化 (bazi.py)

**問題：** 原本使用國曆月份 (`birth_month`) 判斷季節，導致節氣交接時算錯。
**實作要求：** 修改 `get_season_type`，改用八字排盤算出的「月支 (Month Branch)」來判斷季節。

```python
# astro-service/bazi.py
def get_season_type(month_branch: str) -> str:
    if month_branch in ("巳", "午", "未"): return "hot"   # 夏
    if month_branch in ("亥", "子", "丑"): return "cold"  # 冬
    if month_branch in ("寅", "卯", "辰"): return "warm"  # 春
    if month_branch in ("申", "酉", "戌"): return "cool"  # 秋
    return "unknown"

```

*備註：對應的 `compute_match_v2` 中，必須改為讀取 `user.get("bazi_month_branch")` 而非 `birth_month`。*

### 2.2 缺失資料的動態權重計分 (matching.py)

**問題：** Tier 2/3 用戶因為沒有精準出生時間，缺乏 Juno, House 4, Chiron 等資料，原本系統硬塞 `0.65` 會導致分數嚴重失真。
**實作要求：** 在 `compute_soul_score`, `compute_lust_score`, 與 `compute_tracks` 中導入「動態權重 (Dynamic Weighting)」。
**邏輯範例：**

```python
# matching.py
def compute_soul_score(user_a: dict, user_b: dict) -> float:
    score = 0.0
    total_weight = 0.0

    # 必定有的資料
    if user_a.get("moon_sign") and user_b.get("moon_sign"):
        score += compute_sign_aspect(...) * 0.25
        total_weight += 0.25

    # 可能缺失的資料 (Tier 2/3)
    juno_a = user_a.get("juno_sign")
    juno_b = user_b.get("juno_sign")
    if juno_a and juno_b:
        score += compute_sign_aspect(juno_a, juno_b, "harmony") * 0.20
        total_weight += 0.20

    base_score = score / total_weight if total_weight > 0 else 0.65
    # 續接原本的 Multiplier 邏輯...

```

---

## 🧠 3. 全新模組：隱藏心理學萃取引擎 (Psychology Extraction)

**目標：** 不詢問用戶，直接從星盤與紫微盤中「萃取」MBTI 傾向與情緒容量 (Emotional Capacity)。

### 3.1 實作 `extract_deep_psychology` 函數

請在 `chart.py` 或獨立的 `psychology.py` 中實作此計算池。在使用者生成命盤時，同步將結果寫入 User Profile (`inferred_mbti`, `emotional_capacity`)。

**萃取規則 (Scoring Pool)：**

1. **基礎設定：** 預設 `capacity = 50`。
2. **群星覆蓋 (Stellium)：** 掃描 12 宮位，若第 4, 8, 12 宮（水象/隱密宮）內有  顆星：
* `capacity -= 15` (容易吸收負能量而過載)


3. **破壞性相位 (Hard Aspects)：** * 若月亮與冥王星形成刑/衝 (Square/Opposition)：`capacity -= 20`
* 若月亮與土星形成三分/六分 (Trine/Sextile)：`capacity += 15` (情緒防火牆)


4. **紫微斗數聯動 (ZWDS)：**
* 若命宮為空宮：`capacity -= 10` (變色龍體質，易被消耗)
* 若福德宮包含「化忌」或「擎羊/陀羅/火星/鈴星/地空/地劫」：每顆 `capacity -= 10`
* 若命宮包含「紫微」或「天府」：`capacity += 20` (帝王星防護罩)


5. **邊界處理：** 最終 `capacity` 必須限制在 `0` 到 `100` 之間。

### 3.2 將情緒容量整合入伴侶軌 (Partner Track)

在 `matching.py` 的四軌計算中，加入防爆機制：

```python
# 當雙方的情緒容量都極低時，現實伴侶軌道必定崩潰
capacity_a = user_a.get("emotional_capacity", 50)
capacity_b = user_b.get("emotional_capacity", 50)

if capacity_a < 40 and capacity_b < 40:
    partner_track_score *= 0.7  # 雙方皆為情緒海綿，互相內耗
elif capacity_a < 30 or capacity_b < 30:
    partner_track_score *= 0.85 # 一方情緒極度不穩

```

---

## 🎛️ 4. 商業化模組：意圖過濾器 (Intent Filters)

**目標：** 在配對列表 API 中，允許前端傳入 `mode` 參數，動態重新計算總分 (`final_match_score`) 以改變排序。

**實作要求：** 在 `matching.py` 新增 `apply_intent_filter(match_results, mode="balanced")` 函數。

**權重分配邏輯：**

1. **`mode="hunt"` (狩獵模式)：** 找尋激情與致命吸引力。
* `final_score = (lust * 0.6) + (passion * 0.3) + (soul * 0.1)`
* 致命過濾：`if passion < 40: final_score *= 0.5`


2. **`mode="nest"` (築巢模式)：** 找尋安穩長期的正宮。
* `final_score = (partner * 0.5) + (soul * 0.3) + (friend * 0.2)`
* 致命過濾：`if partner < 50: final_score *= 0.6`


3. **`mode="war"` (戰鬥模式)：** 找尋互補的人生戰友。
* RPV 互補分：`rpv_gap = abs(power_diff)`。若 `rpv_gap > 15` 給 100 分，否則 60 分。
* `final_score = (friend * 0.5) + (rpv_complement_score * 0.5)`


4. **`mode="balanced"` (預設模式)：**
* `final_score = (soul * 0.4) + (lust * 0.3) + (partner * 0.3)`



---

## 💾 5. 資料結構更新要求 (Data Structure Updates)

請確保後端在處理 User Profile 時，支援並儲存以下新欄位：

* `bazi_month_branch` (String) - 例如 "卯", "午"
* `inferred_mbti` (String) - 保留欄位，供未來 UI 顯示
* `emotional_capacity` (Integer: 0-100) - 由系統自動萃取

API Response 中應多回傳：

* `final_match_score` (Float) - 經過 Intent Filter 調整後的分數
* `current_mode` (String) - 當前使用的過濾模式