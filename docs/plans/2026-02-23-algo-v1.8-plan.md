# Algorithm v1.8 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** å‡ç´šæ¼”ç®—æ³•è‡³ v1.8ï¼šä¿®å¾© modifier propagation bugã€å…¨é¢æ¡ç”¨ orb-based åº¦æ•¸è¨ˆåˆ†ã€åŠ å…¥ Ascendant å¸å¼•åŠ›äº¤å‰ç›¸ä½ã€åŠ å…¥å—åŒ—äº¤é»æ¥­åŠ›è§¸ç™¼å™¨ï¼Œä¸¦å°‡åº¦æ•¸è³‡æ–™å¾ DB è²«é€šè‡³é…å°è¨ˆç®—å±¤ã€‚

**Architecture:** å››å±¤ä¿®æ”¹ â€” Python æ¼”ç®—æ³•å±¤ (`matching.py`, `shadow_engine.py`, `chart.py`)ã€DB migrationã€Next.js API è³‡æ–™ä¸²æ¥å±¤ (`run/route.ts`, `birth-data/route.ts`)ã€æ¸¬è©¦å±¤ã€‚

**Tech Stack:** Python FastAPI + pyswisseph, Next.js 16 App Router, Supabase PostgreSQL, pytest, Vitest

---

## åŸ·è¡Œå‰ç¢ºèª

```bash
cd astro-service && pytest -v  # æ‡‰å…¨ pass (387 tests)
```

---

## Task 1: Bug Fix â€” compute_match_v2 çš„ lust/soul modifier propagation

plan-1.0 ç™¼ç¾ï¼šshadow engine å’Œ attachment çš„ `soul_adj`/`lust_adj` åªæ›´æ–°äº† `tracks["soul"]` å’Œ `tracks["passion"]`ï¼Œä½† `classify_quadrant(lust, soul)` ä½¿ç”¨çš„æ˜¯ä¿®æ”¹å‰çš„ `lust`/`soul` è®Šæ•¸ï¼Œå°è‡´é›·é”åœ–å’Œè±¡é™åˆ†é¡ä¸ä¸€è‡´ã€‚

**Files:**
- Modify: `astro-service/matching.py`

**Step 1: Write failing test**

åœ¨ `test_matching.py` çš„ `TestComputeMatchV2` class ä¸­åŠ å…¥ï¼š

```python
def test_lust_soul_modifier_propagates_to_axes(self):
    """soul_adj and lust_adj must update lust/soul axes, not just tracks.
    Shadow engine soul_mod += 20 should push soul_score above base, not just tracks["soul"].
    """
    # Trigger a known shadow engine soul boost via Vertex conjunction
    # Use exact degrees: A's Venus at 45.0, B's Vertex at 45.0 â†’ conjunction within 3Â°
    a = {
        "data_tier": 1,
        "sun_sign": "taurus", "sun_degree": 45.0,
        "moon_sign": "taurus", "moon_degree": 45.0,
        "venus_sign": "taurus", "venus_degree": 45.0,
        "mars_sign": "taurus", "mars_degree": 45.0,
        "saturn_sign": "taurus", "saturn_degree": 45.0,
        "ascendant_sign": "taurus", "ascendant_degree": 45.0,
        "bazi_element": None, "rpv_conflict": None, "rpv_power": None, "rpv_energy": None,
    }
    b = {
        "data_tier": 1,
        "sun_sign": "taurus", "sun_degree": 45.0,
        "moon_sign": "taurus", "moon_degree": 45.0,
        "venus_sign": "taurus", "venus_degree": 45.0,
        "mars_sign": "taurus", "mars_degree": 45.0,
        "saturn_sign": "taurus", "saturn_degree": 45.0,
        "ascendant_sign": "taurus", "ascendant_degree": 45.0,
        "vertex_degree": 45.5,  # triggers A_Venus_Conjunct_Vertex (within 3Â°)
        "bazi_element": None, "rpv_conflict": None, "rpv_power": None, "rpv_energy": None,
    }
    result = compute_match_v2(a, b)
    # soul_score must reflect the shadow engine boost
    # If fix is not applied, soul_score == base_soul (unchanged despite soul_adj)
    assert result["soul_score"] >= 50.0, (
        f"soul_score {result['soul_score']} should be boosted by shadow engine trigger"
    )
    # psychological_tags should contain the Vertex trigger
    assert any("Vertex" in t for t in result.get("psychological_tags", [])), (
        "Vertex trigger tag should appear in psychological_tags"
    )
```

**Step 2: Run test to verify it fails**

```bash
cd astro-service && pytest test_matching.py -k "test_lust_soul_modifier_propagates" -v
```

Expected: FAIL (soul_score is not boosted)

**Step 3: Apply the fix in matching.py**

æ‰¾åˆ° `compute_match_v2` ä¸­çš„ `# Apply modifiers` æ®µè½ï¼ˆç´„ line 266ï¼‰ï¼š

```python
    # Apply modifiers â€” clamp each track to [0, 100]
    if soul_adj != 0.0:
        tracks["soul"]    = _clamp(tracks["soul"]    + soul_adj)
    if lust_adj != 0.0:
        tracks["passion"] = _clamp(tracks["passion"] + lust_adj)
    if partner_adj != 0.0:
        tracks["partner"] = _clamp(tracks["partner"] + partner_adj)
```

Replace with:

```python
    # Apply modifiers â€” clamp each track to [0, 100]
    if soul_adj != 0.0:
        tracks["soul"] = _clamp(tracks["soul"] + soul_adj)
        soul           = _clamp(soul + soul_adj)   # propagate to Y-axis score
    if lust_adj != 0.0:
        tracks["passion"] = _clamp(tracks["passion"] + lust_adj)
        lust              = _clamp(lust + lust_adj)   # propagate to X-axis score
    if partner_adj != 0.0:
        tracks["partner"] = _clamp(tracks["partner"] + partner_adj)
```

**Step 4: Run test to verify it passes**

```bash
cd astro-service && pytest test_matching.py -k "test_lust_soul_modifier_propagates" -v
```

Expected: PASS

**Step 5: Run full test suite**

```bash
cd astro-service && pytest -v
```

Expected: All 387 tests pass (+ 1 new = 388)

**Step 6: Commit**

```bash
git add astro-service/matching.py astro-service/test_matching.py
git commit -m "fix(matching): propagate soul_adj/lust_adj to lust/soul axes in compute_match_v2"
```

---

## Task 2: compute_kernel_score â†’ _resolve_aspect (åº¦æ•¸å‡ç´š)

`compute_kernel_score` ç›®å‰ä½¿ç”¨ `compute_sign_aspect()`ï¼Œç„¡æ³•æ•æ‰è·¨æ˜Ÿåº§çš„çœŸå¯¦åˆç›¸ï¼ˆå¦‚ç‰¡ç¾Š 29Â° + é‡‘ç‰› 1Â°ï¼‰ã€‚æ”¹ç”¨å·²æœ‰çš„ `_resolve_aspect()`ï¼šæœ‰åº¦æ•¸ç”¨åº¦æ•¸ï¼Œæ²’æœ‰åº¦æ•¸é€€å›æ˜Ÿåº§ã€‚

**Files:**
- Modify: `astro-service/matching.py` (compute_kernel_score å‡½å¼)

**Step 1: Write failing test**

åœ¨ `TestComputeKernelScore` class ä¸­åŠ å…¥ï¼š

```python
def test_cross_sign_conjunction_scores_high(self):
    """Aries 29Â° (lon=29.0) and Taurus 1Â° (lon=31.0) â†’ 2Â° apart â†’ should score as conjunction.
    With sign-level only: Aries vs Taurus = semi-sextile (0.10). Bad!
    With _resolve_aspect + exact degrees: conjunction 2Â° â†’ ~0.80. Correct!
    """
    a = {
        "data_tier": 1,
        "sun_degree": 29.0, "sun_sign": "aries",    # Aries 29Â°
        "moon_degree": 45.0, "moon_sign": "taurus",
        "venus_degree": 90.0, "venus_sign": "cancer",
        "ascendant_degree": 0.0, "ascendant_sign": "aries",
        "bazi_element": None,
    }
    b = {
        "data_tier": 1,
        "sun_degree": 31.0, "sun_sign": "taurus",   # Taurus 1Â° â†’ only 2Â° from A's sun
        "moon_degree": 45.0, "moon_sign": "taurus",
        "venus_degree": 90.0, "venus_sign": "cancer",
        "ascendant_degree": 0.0, "ascendant_sign": "aries",
        "bazi_element": None,
    }
    score = compute_kernel_score(a, b)
    # Sun contribution: conjunction 2Â° â†’ harmony ~0.80 (was 0.10 with sign-level)
    # Overall kernel score should be significantly higher than if sign-level used
    assert score >= 0.70, (
        f"Cross-sign conjunction kernel score {score:.3f} should be >= 0.70"
    )
```

**Step 2: Run test to verify it fails**

```bash
cd astro-service && pytest test_matching.py -k "test_cross_sign_conjunction_scores_high" -v
```

Expected: FAIL (score is low due to sign-level semi-sextile)

**Step 3: Replace compute_kernel_score body in matching.py**

æ‰¾åˆ°ç¾æœ‰çš„ `compute_kernel_score` å‡½å¼ï¼ˆç´„ line 300ï¼‰ï¼Œå°‡ `sun`/`moon`/`venus`/`asc` å››è¡Œæ›¿æ›ï¼š

```python
# Before (sign-level only):
sun   = compute_sign_aspect(user_a.get("sun_sign"),        user_b.get("sun_sign"),        "harmony")
moon  = compute_sign_aspect(user_a.get("moon_sign"),       user_b.get("moon_sign"),       "harmony")
venus = compute_sign_aspect(user_a.get("venus_sign"),      user_b.get("venus_sign"),      "harmony")
asc   = compute_sign_aspect(user_a.get("ascendant_sign"),  user_b.get("ascendant_sign"),  "harmony")

# After (degree-first, sign fallback):
sun   = _resolve_aspect(user_a.get("sun_degree"),        user_a.get("sun_sign"),
                        user_b.get("sun_degree"),        user_b.get("sun_sign"),        "harmony")
moon  = _resolve_aspect(user_a.get("moon_degree"),       user_a.get("moon_sign"),
                        user_b.get("moon_degree"),       user_b.get("moon_sign"),       "harmony")
venus = _resolve_aspect(user_a.get("venus_degree"),      user_a.get("venus_sign"),
                        user_b.get("venus_degree"),      user_b.get("venus_sign"),      "harmony")
asc   = _resolve_aspect(user_a.get("ascendant_degree"),  user_a.get("ascendant_sign"),
                        user_b.get("ascendant_degree"),  user_b.get("ascendant_sign"),  "harmony")
```

**Step 4: Run test to verify it passes**

```bash
cd astro-service && pytest test_matching.py -k "test_cross_sign_conjunction_scores_high" -v
```

Expected: PASS

**Step 5: Run full suite**

```bash
cd astro-service && pytest test_matching.py -v
```

Expected: All passing

**Step 6: Commit**

```bash
git add astro-service/matching.py astro-service/test_matching.py
git commit -m "feat(kernel): upgrade compute_kernel_score to _resolve_aspect for orb-based accuracy"
```

---

## Task 3: compute_glitch_score â†’ _resolve_aspect (åº¦æ•¸å‡ç´š)

èˆ‡ Task 2 ç›¸åŒåŸå‰‡ï¼Œå‡ç´š Glitch (æ‘©æ“¦å®¹å¿åº¦) è¨ˆåˆ†ã€‚

**Files:**
- Modify: `astro-service/matching.py` (compute_glitch_score å‡½å¼)

**Step 1: Write failing test**

åœ¨ `TestComputeGlitchScore` class ä¸­åŠ å…¥ï¼š

```python
def test_cross_sign_mars_scores_correctly(self):
    """Mars Aries 29Â° vs Mars Taurus 1Â° â†’ 2Â° apart â†’ should score as conjunction (tension).
    tension conjunction â†’ 1.0 * linear decay â†’ ~0.80 (not 0.10 semi-sextile).
    """
    a = {
        "mars_degree": 29.0, "mars_sign": "aries",
        "saturn_degree": 90.0, "saturn_sign": "cancer",
    }
    b = {
        "mars_degree": 31.0, "mars_sign": "taurus",
        "saturn_degree": 90.0, "saturn_sign": "cancer",
    }
    score = compute_glitch_score(a, b)
    # With degree-based: mars conjunction 2Â° tension â†’ ~0.80, weighted Ã— 0.25
    # With sign-level: aries vs taurus semi-sextile â†’ 0.10, weighted Ã— 0.25
    # Score with degrees should be noticeably higher
    assert score >= 0.35, (
        f"Cross-sign Mars conjunction glitch score {score:.3f} should reflect true conjunction"
    )
```

**Step 2: Run test to verify it fails**

```bash
cd astro-service && pytest test_matching.py -k "test_cross_sign_mars_scores_correctly" -v
```

**Step 3: Replace compute_glitch_score body in matching.py**

æ‰¾åˆ°ç¾æœ‰çš„ `compute_glitch_score` å‡½å¼ï¼ˆç´„ line 372ï¼‰ï¼Œæ›¿æ›å››è¡Œè¨ˆç®—ï¼š

```python
# Before:
mars        = compute_sign_aspect(user_a.get("mars_sign"),   user_b.get("mars_sign"),    "tension")
saturn      = compute_sign_aspect(user_a.get("saturn_sign"), user_b.get("saturn_sign"),  "harmony")
mars_sat_ab = compute_sign_aspect(user_a.get("mars_sign"),   user_b.get("saturn_sign"),  "tension")
mars_sat_ba = compute_sign_aspect(user_b.get("mars_sign"),   user_a.get("saturn_sign"),  "tension")

# After:
mars        = _resolve_aspect(user_a.get("mars_degree"),   user_a.get("mars_sign"),
                              user_b.get("mars_degree"),   user_b.get("mars_sign"),    "tension")
saturn      = _resolve_aspect(user_a.get("saturn_degree"), user_a.get("saturn_sign"),
                              user_b.get("saturn_degree"), user_b.get("saturn_sign"),  "harmony")
mars_sat_ab = _resolve_aspect(user_a.get("mars_degree"),   user_a.get("mars_sign"),
                              user_b.get("saturn_degree"), user_b.get("saturn_sign"),  "tension")
mars_sat_ba = _resolve_aspect(user_b.get("mars_degree"),   user_b.get("mars_sign"),
                              user_a.get("saturn_degree"), user_a.get("saturn_sign"),  "tension")
```

**Step 4: Run tests**

```bash
cd astro-service && pytest test_matching.py -v
```

Expected: All passing

**Step 5: Commit**

```bash
git add astro-service/matching.py astro-service/test_matching.py
git commit -m "feat(glitch): upgrade compute_glitch_score to _resolve_aspect for orb-based accuracy"
```

---

## Task 4: ä¸Šå‡æ˜Ÿåº§ (ASC) äº¤å‰ç›¸ä½åŠ å…¥ compute_lust_score

ã€Œè¦‹é¢ç¬¬ä¸€çœ¼å°±æƒ³æ’²å€’ã€çš„ç‰©ç†å¸å¼•åŠ›ï¼šA çš„ç«æ˜Ÿ/é‡‘æ˜Ÿç²¾æº–è½åœ¨ B çš„ä¸Šå‡æ˜Ÿåº§æ™‚ï¼Œè‚‰é«”å¸å¼•åŠ›çˆ†è¡¨ã€‚
åªæœ‰ç•¶é›™æ–¹å‡æœ‰ç²¾ç¢º ASC degreeï¼ˆTier 1ï¼‰æ™‚æ‰è§¸ç™¼ï¼›ç¼ºå°‘æ™‚è‡ªå‹•è·³éï¼ˆä¸åŠ  neutral èª¤å·®ï¼‰ã€‚

**Files:**
- Modify: `astro-service/matching.py` (WEIGHTS dict + compute_lust_score å‡½å¼)

**Step 1: Add new WEIGHTS keys**

åœ¨ `WEIGHTS` dict çš„ `# â”€â”€ compute_lust_score` æ®µè½æœ«å°¾åŠ å…¥ 4 å€‹æ–° keyï¼š

```python
    # ASC cross-aspects (first-impression physical pull, Tier 1 only â€” requires exact degree)
    "lust_mars_asc_ab":   0.10,   # mars_a Ã— asc_b  (tension â€” A's drive ignites B's persona)
    "lust_mars_asc_ba":   0.10,   # mars_b Ã— asc_a  (tension â€” B's drive ignites A's persona)
    "lust_venus_asc_ab":  0.10,   # venus_a Ã— asc_b (harmony â€” A's allure fits B's appearance)
    "lust_venus_asc_ba":  0.10,   # venus_b Ã— asc_a (harmony â€” B's allure fits A's appearance)
```

**Step 2: Write failing test**

åœ¨ `TestComputeLustScore` class ä¸­åŠ å…¥ï¼š

```python
def test_asc_cross_aspect_boosts_lust_tier1(self):
    """Mars exact conjunction with partner's ASC (tension) should boost lust score for Tier 1."""
    base = {
        "data_tier": 1,
        "mars_sign": "aries",     "mars_degree":  0.0,
        "venus_sign": "taurus",   "venus_degree": 30.0,
        "ascendant_sign": "leo",  "ascendant_degree": 120.0,
        "bazi_element": None, "rpv_conflict": None, "rpv_power": None, "rpv_energy": None,
    }
    # B's ASC at exactly 1.0Â° â€” near A's Mars at 0.0Â° â†’ conjunction 1Â° â†’ strong tension
    b_with_asc = {
        "data_tier": 1,
        "mars_sign": "aries",     "mars_degree":  10.0,
        "venus_sign": "taurus",   "venus_degree": 30.0,
        "ascendant_sign": "aries", "ascendant_degree": 1.0,   # 1Â° from A's Mars
        "bazi_element": None, "rpv_conflict": None, "rpv_power": None, "rpv_energy": None,
    }
    # B without ASC â€” same Tier 1 but no ASC degree
    b_no_asc = {
        "data_tier": 1,
        "mars_sign": "aries",     "mars_degree":  10.0,
        "venus_sign": "taurus",   "venus_degree": 30.0,
        "ascendant_sign": None,   "ascendant_degree": None,
        "bazi_element": None, "rpv_conflict": None, "rpv_power": None, "rpv_energy": None,
    }
    score_with = compute_lust_score(base, b_with_asc)
    score_without = compute_lust_score(base, b_no_asc)
    assert score_with > score_without, (
        f"Lust score with ASC conjunction ({score_with:.1f}) should beat without ASC ({score_without:.1f})"
    )

def test_asc_cross_aspect_absent_tier2(self):
    """Tier 2 user has no ASC degree â€” ASC terms are skipped, score normalizes correctly."""
    a = {
        "data_tier": 2,
        "mars_sign": "aries",   "mars_degree": 0.0,
        "venus_sign": "taurus", "venus_degree": 30.0,
        "ascendant_sign": None, "ascendant_degree": None,
        "bazi_element": None, "rpv_conflict": None, "rpv_power": None, "rpv_energy": None,
    }
    b = dict(a)
    score = compute_lust_score(a, b)
    assert 0.0 <= score <= 100.0
```

**Step 3: Run tests to verify they fail**

```bash
cd astro-service && pytest test_matching.py -k "test_asc_cross_aspect" -v
```

**Step 4: Add ASC cross-aspect terms to compute_lust_score**

åœ¨ `compute_lust_score` çš„ `# 6. Karmic triggers` æ®µè½ä¹‹å‰åŠ å…¥ï¼ˆç´„ line 624ï¼‰ï¼š

```python
    # 5b. Ascendant cross-aspects (first-impression physical pull, Tier 1 only)
    # Only added when exact degrees available â€” avoids neutral-score contamination for Tier 2/3
    asc_a_deg = user_a.get("ascendant_degree")
    asc_b_deg = user_b.get("ascendant_degree")
    if mars_a_deg is not None and asc_b_deg is not None:
        w = WEIGHTS["lust_mars_asc_ab"]
        score += compute_exact_aspect(mars_a_deg, asc_b_deg, "tension") * w
        total_weight += w
    if mars_b_deg is not None and asc_a_deg is not None:
        w = WEIGHTS["lust_mars_asc_ba"]
        score += compute_exact_aspect(mars_b_deg, asc_a_deg, "tension") * w
        total_weight += w
    if venus_a_deg is not None and asc_b_deg is not None:
        w = WEIGHTS["lust_venus_asc_ab"]
        score += compute_exact_aspect(venus_a_deg, asc_b_deg, "harmony") * w
        total_weight += w
    if venus_b_deg is not None and asc_a_deg is not None:
        w = WEIGHTS["lust_venus_asc_ba"]
        score += compute_exact_aspect(venus_b_deg, asc_a_deg, "harmony") * w
        total_weight += w
```

**Step 5: Run tests**

```bash
cd astro-service && pytest test_matching.py -v
```

Expected: All passing

**Step 6: Commit**

```bash
git add astro-service/matching.py astro-service/test_matching.py
git commit -m "feat(lust): add ASC cross-aspect terms (Mars/Venus Ã— partner ASC) to compute_lust_score"
```

---

## Task 5: Lunar Nodes extraction in chart.py

`swe.TRUE_NODE` ä¸éœ€è¦å‡ºç”Ÿæ™‚é–“ï¼Œæ‰€æœ‰ Tier éƒ½å¯ä»¥è¨ˆç®—ã€‚å—äº¤é» = åŒ—äº¤é» + 180Â°ã€‚

**Files:**
- Modify: `astro-service/chart.py` (calculate_chart å‡½å¼)

**Step 1: Write failing test**

åœ¨ `test_chart.py` ä¸­æ‰¾åˆ°åˆé©çš„ test classï¼ŒåŠ å…¥ï¼š

```python
class TestLunarNodes:
    def test_north_node_returned_all_tiers(self):
        """north_node_degree and north_node_sign should be present for all data tiers."""
        for tier in [1, 2, 3]:
            result = calculate_chart(
                birth_date="1995-06-15",
                data_tier=tier,
                lat=25.033, lng=121.565,
            )
            assert "north_node_degree" in result
            assert "north_node_sign"   in result
            assert result["north_node_degree"] is not None, f"Tier {tier}: north_node_degree is None"
            assert result["north_node_sign"]   is not None, f"Tier {tier}: north_node_sign is None"
            assert 0.0 <= result["north_node_degree"] < 360.0

    def test_south_node_is_opposite_north(self):
        """south_node_degree == (north_node_degree + 180) % 360."""
        result = calculate_chart(birth_date="1995-06-15", data_tier=1)
        nn = result["north_node_degree"]
        sn = result["south_node_degree"]
        expected_sn = (nn + 180.0) % 360.0
        assert abs(sn - expected_sn) < 0.01, f"SN {sn} != NN + 180Â° ({expected_sn})"

    def test_south_node_sign_correct(self):
        """south_node_sign matches longitude_to_sign(south_node_degree)."""
        result = calculate_chart(birth_date="1990-01-01", data_tier=2)
        sn_deg  = result["south_node_degree"]
        expected_sign = SIGNS[int(sn_deg // 30) % 12]
        assert result["south_node_sign"] == expected_sign
```

**Step 2: Run tests to verify they fail**

```bash
cd astro-service && pytest test_chart.py -k "TestLunarNodes" -v
```

**Step 3: Add node calculation to calculate_chart**

åœ¨ `chart.py` çš„ `calculate_chart` å‡½å¼ä¸­ï¼Œåœ¨ `# â”€â”€ Asteroids` æ®µè½ä¹‹å¾ŒåŠ å…¥ï¼ˆTier restriction ä¹‹å‰ï¼‰ï¼š

```python
    # â”€â”€ Lunar Nodes (å—åŒ—äº¤é») â€” available at all tiers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # swe.TRUE_NODE does not require birth time; safe for Tier 2/3.
    try:
        nn_pos, _ = swe.calc_ut(jd, swe.TRUE_NODE)
        nn_deg = round(nn_pos[0], 2)
        result["north_node_sign"]   = longitude_to_sign(nn_deg)
        result["north_node_degree"] = nn_deg
        sn_deg = round((nn_deg + 180.0) % 360.0, 2)
        result["south_node_sign"]   = longitude_to_sign(sn_deg)
        result["south_node_degree"] = sn_deg
    except Exception:
        result["north_node_sign"]   = None
        result["north_node_degree"] = None
        result["south_node_sign"]   = None
        result["south_node_degree"] = None
```

Also import `SIGNS` if not already accessible in that scope (it is â€” it's at module level).

**Step 4: Run tests**

```bash
cd astro-service && pytest test_chart.py -k "TestLunarNodes" -v
```

Expected: PASS

**Step 5: Run full Python test suite**

```bash
cd astro-service && pytest -v
```

Expected: All passing + 3 new node tests

**Step 6: Commit**

```bash
git add astro-service/chart.py astro-service/test_chart.py
git commit -m "feat(chart): add North/South Lunar Node extraction (all tiers) to calculate_chart"
```

---

## Task 6: Migration 012 â€” north_node / south_node DB æ¬„ä½

**Files:**
- Create: `destiny-app/supabase/migrations/012_lunar_nodes.sql`
- Modify: `destiny-app/src/lib/supabase/types.ts`

**Step 1: Create migration file**

```sql
-- Migration 012: Add Lunar Node columns
-- North Node (True Node) and South Node (180Â° opposite) for karmic synastry triggers.
-- Available at all tiers since swe.TRUE_NODE does not require birth time.

ALTER TABLE public.users
  ADD COLUMN IF NOT EXISTS north_node_sign   TEXT,
  ADD COLUMN IF NOT EXISTS north_node_degree DOUBLE PRECISION,
  ADD COLUMN IF NOT EXISTS south_node_sign   TEXT,
  ADD COLUMN IF NOT EXISTS south_node_degree DOUBLE PRECISION;

COMMENT ON COLUMN public.users.north_node_sign   IS 'True North Node zodiac sign (available all tiers)';
COMMENT ON COLUMN public.users.north_node_degree IS 'True North Node ecliptic longitude 0-360Â°';
COMMENT ON COLUMN public.users.south_node_sign   IS 'South Node zodiac sign (= north_node_degree + 180Â°)';
COMMENT ON COLUMN public.users.south_node_degree IS 'South Node ecliptic longitude 0-360Â°';
```

**Step 2: Update types.ts**

åœ¨ `src/lib/supabase/types.ts` çš„ `users` Table Row å‹åˆ¥ä¸­ï¼Œåœ¨ç¾æœ‰æ¬„ä½å¾ŒåŠ å…¥ï¼š

```typescript
north_node_sign:   string | null
north_node_degree: number | null
south_node_sign:   string | null
south_node_degree: number | null
```

åŒæ¨£åœ¨ `Insert` å’Œ `Update` ä»‹é¢ä¸­åŠ å…¥ï¼ˆoptionalï¼‰ï¼š

```typescript
north_node_sign?:   string | null
north_node_degree?: number | null
south_node_sign?:   string | null
south_node_degree?: number | null
```

**Step 3: Push migration to Supabase**

```bash
cd destiny-app
npx supabase db push
```

Expected: Migration applied successfully

**Step 4: Commit**

```bash
git add destiny-app/supabase/migrations/012_lunar_nodes.sql destiny-app/src/lib/supabase/types.ts
git commit -m "feat(db): migration 012 â€” add north_node/south_node columns to users table"
```

---

## Task 7: birth-data API â€” å›å¯« Lunar Nodes åˆ° DB

**Files:**
- Modify: `destiny-app/src/app/api/onboarding/birth-data/route.ts`

**Step 1: Update degreeFields array**

æ‰¾åˆ° `const degreeFields = [...]` æ®µè½ï¼ˆç´„ line 267ï¼‰ï¼ŒåŠ å…¥å…©å€‹æ–° entryï¼š

```typescript
const degreeFields = [
  'sun', 'moon', 'mercury', 'venus', 'mars', 'jupiter', 'saturn',
  'uranus', 'neptune', 'pluto', 'chiron', 'juno',
  'ascendant', 'house4', 'house8', 'house12',
  'north_node', 'south_node',   // ğŸ†•
]
```

**Step 2: Update the supabase .update() call**

åœ¨ `await supabase.from('users').update({...})` ä¸­åŠ å…¥ï¼š

```typescript
          // Algorithm v1.8: Lunar Nodes (all tiers)
          north_node_sign:   chart.north_node_sign   ?? null,
          north_node_degree: chart.north_node_degree ?? null,
          south_node_sign:   chart.south_node_sign   ?? null,
          south_node_degree: chart.south_node_degree ?? null,
```

**Step 3: Update tests**

åœ¨ `src/__tests__/api/onboarding-birth-data.test.ts` ä¸­ï¼Œç¢ºèªç¯€é»æ¬„ä½è¢«å¯«å›ã€‚æ‰¾åˆ°æ¸¬è©¦ä¸­ mock çš„ `supabase.from().update()` assertionï¼Œç¢ºä¿ `north_node_sign` å‡ºç¾åœ¨æ›´æ–°è³‡æ–™ä¸­ã€‚è¦–ç¾æœ‰ mock çµæ§‹åŠ å…¥ï¼š

```typescript
expect(mockUpdate).toHaveBeenCalledWith(
  expect.objectContaining({
    north_node_sign:   expect.anything(),
    north_node_degree: expect.anything(),
    south_node_sign:   expect.anything(),
    south_node_degree: expect.anything(),
  })
)
```

**Step 4: Run JS tests**

```bash
cd destiny-app && npx vitest run
```

Expected: All 91 tests pass

**Step 5: Commit**

```bash
git add destiny-app/src/app/api/onboarding/birth-data/route.ts destiny-app/src/__tests__/api/onboarding-birth-data.test.ts
git commit -m "feat(birth-data): write-back north_node/south_node fields from chart calculation"
```

---

## Task 8: Lunar Node shadow triggers in shadow_engine.py + prompt_manager.py

è§¸ç™¼è¦å‰‡ï¼ˆplan-1.0ï¼‰ï¼š
- A çš„æ—¥/æœˆ/é‡‘/ç«ç²¾æº–åˆç›¸ B çš„**å—äº¤é»** (3Â° orb)ï¼š`soul_mod += 20`ã€`high_voltage = True`ï¼ˆå‰ä¸–æ¥­åŠ›ï¼‰
- A çš„æ—¥/æœˆ/é‡‘/ç«ç²¾æº–åˆç›¸ B çš„**åŒ—äº¤é»** (3Â° orb)ï¼š`soul_mod += 20`ï¼ˆä»Šç”Ÿå®¿å‘½ï¼‰
- åå‘ï¼ˆB è§¸ç¢° A çš„äº¤é»ï¼‰åŒç†

**Files:**
- Modify: `astro-service/shadow_engine.py`
- Modify: `astro-service/prompt_manager.py`

**Step 1: Write failing tests**

åœ¨ `test_shadow_engine.py` ä¸­åŠ å…¥ï¼š

```python
class TestLunarNodeTriggers:
    def _base(self):
        return {
            "sun_degree": 0.0, "moon_degree": 90.0,
            "venus_degree": 180.0, "mars_degree": 270.0,
            "chiron_degree": None, "pluto_degree": None,
            "house12_sign": None, "attachment_style": None,
        }

    def test_south_node_trigger_high_voltage(self):
        """A's Sun conjunct B's South Node within 3Â° â†’ soul_mod += 20 + high_voltage."""
        a = self._base()
        b = {**self._base(), "south_node_degree": 1.5}  # 1.5Â° from A's Sun (0.0)
        result = compute_shadow_and_wound(a, b)
        assert result["soul_mod"] >= 20.0
        assert result["high_voltage"] is True
        assert "A_Sun_Conjunct_South_Node" in result["shadow_tags"]

    def test_north_node_trigger_no_high_voltage(self):
        """A's Moon conjunct B's North Node within 3Â° â†’ soul_mod += 20, no high_voltage."""
        a = self._base()
        b = {**self._base(), "north_node_degree": 91.0}  # 1Â° from A's Moon (90.0)
        result = compute_shadow_and_wound(a, b)
        assert result["soul_mod"] >= 20.0
        # North Node alone does not set high_voltage
        assert "A_Moon_Conjunct_North_Node" in result["shadow_tags"]

    def test_node_trigger_outside_orb_no_effect(self):
        """Node 5Â° away (beyond 3Â° orb) should not trigger."""
        a = self._base()
        b = {**self._base(), "north_node_degree": 5.0}  # 5Â° from Sun â€” outside 3Â° orb
        result = compute_shadow_and_wound(a, b)
        assert not any("North_Node" in t for t in result["shadow_tags"])

    def test_missing_node_skipped_gracefully(self):
        """Missing north_node_degree / south_node_degree should not raise."""
        a = self._base()
        b = self._base()  # no node fields
        result = compute_shadow_and_wound(a, b)
        assert "soul_mod" in result
```

**Step 2: Run tests to verify they fail**

```bash
cd astro-service && pytest test_shadow_engine.py -k "TestLunarNodeTriggers" -v
```

**Step 3: Add Node constants + trigger logic to shadow_engine.py**

åœ¨ `shadow_engine.py` çš„ constants æ®µè½åŠ å…¥ï¼š

```python
# Orb for Lunar Node (å—åŒ—äº¤é») karmic triggers (conjunction only)
_NODE_ORB = 3.0

# Planets checked against partner's Nodes (Sun/Moon/Venus/Mars â€” personal planets only)
_NODE_PLANETS = [
    ("Sun",   "sun_degree"),
    ("Moon",  "moon_degree"),
    ("Venus", "venus_degree"),
    ("Mars",  "mars_degree"),
]
```

åœ¨ `compute_shadow_and_wound` å‡½å¼ä¸­ï¼Œåœ¨ Lilith triggers æ®µè½ä¹‹å¾ŒåŠ å…¥ï¼š

```python
    # Lunar Node triggers (æ¥­åŠ›ä¹‹è¼ª): å—åŒ—äº¤é»æ¥­åŠ›åˆç›¸
    nn_a = chart_a.get("north_node_degree")
    sn_a = chart_a.get("south_node_degree")
    nn_b = chart_b.get("north_node_degree")
    sn_b = chart_b.get("south_node_degree")

    # A's personal planets conjunct B's nodes
    for p_name, p_key in _NODE_PLANETS:
        deg_a = chart_a.get(p_key)
        if deg_a is None:
            continue
        # South Node: å‰ä¸–å®¿å‚µ + high_voltage
        d_sn = _dist(deg_a, sn_b)
        if d_sn is not None and d_sn <= _NODE_ORB:
            result["soul_mod"] += 20.0
            result["high_voltage"] = True
            result["shadow_tags"].append(f"A_{p_name}_Conjunct_South_Node")
        # North Node: ä»Šç”Ÿå®¿å‘½å¼•é ˜
        d_nn = _dist(deg_a, nn_b)
        if d_nn is not None and d_nn <= _NODE_ORB:
            result["soul_mod"] += 20.0
            result["shadow_tags"].append(f"A_{p_name}_Conjunct_North_Node")

    # B's personal planets conjunct A's nodes
    for p_name, p_key in _NODE_PLANETS:
        deg_b = chart_b.get(p_key)
        if deg_b is None:
            continue
        d_sn = _dist(deg_b, sn_a)
        if d_sn is not None and d_sn <= _NODE_ORB:
            result["soul_mod"] += 20.0
            result["high_voltage"] = True
            result["shadow_tags"].append(f"B_{p_name}_Conjunct_South_Node")
        d_nn = _dist(deg_b, nn_a)
        if d_nn is not None and d_nn <= _NODE_ORB:
            result["soul_mod"] += 20.0
            result["shadow_tags"].append(f"B_{p_name}_Conjunct_North_Node")
```

**Step 4: Add zh translations to prompt_manager.py**

åœ¨ `prompt_manager.py` çš„ tag å­—å…¸æœ«å°¾ï¼ˆLilith triggers æ®µè½ä¹‹å¾Œï¼‰åŠ å…¥ï¼š

```python
    # Lunar Node triggers (æ¥­åŠ›ä¹‹è¼ª â€” å—åŒ—äº¤é»)
    "A_Sun_Conjunct_South_Node":    "ä½ çš„æ ¸å¿ƒè‡ªæˆ‘ç²¾æº–è§¸ç¢°å°æ–¹çš„å‰ä¸–è¨˜æ†¶ä¹‹é»ï¼Œä»–å°ä½ æœ‰ä¸€ç¨®è«åå…¶å¦™çš„ç„¡æ¢ä»¶åŒ…å®¹",
    "A_Moon_Conjunct_South_Node":   "ä½ çš„æƒ…æ„Ÿæœ¬èƒ½è½åœ¨å°æ–¹éˆé­‚æœ€æ·±çš„èˆ’é©åœˆï¼Œé€™æ˜¯å‰ä¸–ç©æ¬ çš„å®‰å…¨æ„Ÿ",
    "A_Venus_Conjunct_South_Node":  "ä½ çš„æ„›æ„ç²¾æº–å–šèµ·å°æ–¹å‰ä¸–çš„è¨˜æ†¶ï¼Œç¬¬ä¸€æ¬¡è¦‹é¢å°±æœ‰å¼·çƒˆçš„ç†Ÿæ‚‰æ„Ÿ",
    "A_Mars_Conjunct_South_Node":   "ä½ çš„æ…¾æœ›è§¸ç¢°å°æ–¹çš„å‰ä¸–èˆ’é©åœˆï¼Œä»–æœƒç„¡æ¢ä»¶è¢«ä½ å¸å¼•ï¼Œç”šè‡³ä¸æ˜æ‰€ä»¥",
    "A_Sun_Conjunct_North_Node":    "ä½ çš„å­˜åœ¨æ˜¯å°æ–¹ä»Šç”Ÿéˆé­‚é€²åŒ–çš„å‚¬åŒ–åŠ‘ï¼Œæ³¨å®šè¦å¸¶ä»–èµ°å‡ºèˆ’é©åœˆ",
    "A_Moon_Conjunct_North_Node":   "ä½ çš„æƒ…æ„Ÿå›æ‡‰æ–¹å¼ï¼Œæ­£æ˜¯å°æ–¹ä»Šç”Ÿéœ€è¦å­¸ç¿’çš„éˆé­‚åŠŸèª²",
    "A_Venus_Conjunct_North_Node":  "ä½ ä»£è¡¨å°æ–¹ä»Šç”Ÿåœ¨æ„›æƒ…ä¸­éœ€è¦çªç ´çš„æ–¹å‘ï¼Œé€™æ®µé—œä¿‚æ³¨å®šå……æ»¿æˆé•·",
    "A_Mars_Conjunct_North_Node":   "ä½ çš„è¡Œå‹•åŠ›èˆ‡æ…¾æœ›ï¼Œå¼·è¡Œæ‹‰è‘—å°æ–¹æœä»Šç”Ÿå®¿å‘½çš„æ–¹å‘å‰é€²",
    "B_Sun_Conjunct_South_Node":    "å°æ–¹çš„æ ¸å¿ƒè‡ªæˆ‘ç²¾æº–è§¸ç¢°ä½ çš„å‰ä¸–è¨˜æ†¶ï¼Œä½ å°ä»–æœ‰è«åçš„åŒ…å®¹èˆ‡ç†Ÿæ‚‰æ„Ÿ",
    "B_Moon_Conjunct_South_Node":   "å°æ–¹çš„æƒ…æ„Ÿæ–¹å¼è½åœ¨ä½ éˆé­‚æœ€æ·±çš„èˆ’é©åœˆï¼Œæ˜¯å‰ä¸–å°±äº’ç›¸ä¾åçš„æº«æŸ”",
    "B_Venus_Conjunct_South_Node":  "å°æ–¹çš„æ„›æ„ç²¾æº–è§¸ç¢°ä½ çš„å‰ä¸–è¨˜æ†¶ï¼Œç¬¬ä¸€æ¬¡è¦‹é¢ä½ å°±è¦ºå¾—èªè­˜ä»–å¾ˆä¹…äº†",
    "B_Mars_Conjunct_South_Node":   "å°æ–¹çš„æ…¾æœ›è§¸ç¢°ä½ çš„å‰ä¸–èˆ’é©åœˆï¼Œä½ æœƒè¢«ä»–è«åå¸å¼•ï¼Œç”šè‡³ç„¡æ³•æŠ—æ‹’",
    "B_Sun_Conjunct_North_Node":    "å°æ–¹çš„å­˜åœ¨æ˜¯ä½ ä»Šç”Ÿéˆé­‚é€²åŒ–çš„è§¸ç™¼é»ï¼Œä»–æ³¨å®šè¦æ¨ä½ èµ°å‡ºèˆ’é©åœˆ",
    "B_Moon_Conjunct_North_Node":   "å°æ–¹çš„æƒ…æ„Ÿæ–¹å¼ï¼Œæ­£æ˜¯ä½ ä»Šç”Ÿåœ¨è¦ªå¯†é—œä¿‚ä¸­éœ€è¦å­¸ç¿’çš„éˆé­‚åŠŸèª²",
    "B_Venus_Conjunct_North_Node":  "å°æ–¹ä»£è¡¨ä½ ä»Šç”Ÿåœ¨æ„›æƒ…ä¸­éœ€è¦çªç ´çš„å®¿å‘½ï¼Œé€™æ®µé—œä¿‚æ³¨å®šè®“ä½ è›»è®Š",
    "B_Mars_Conjunct_North_Node":   "å°æ–¹çš„è¡Œå‹•åŠ›èˆ‡æ…¾æœ›ï¼Œå¼·è¡Œæ‹‰è‘—ä½ æœä»Šç”Ÿå®¿å‘½çš„æ–¹å‘å¥”å»ï¼Œä»¤äººåˆæ„›åˆæ€•",
```

**Step 5: Run shadow engine tests**

```bash
cd astro-service && pytest test_shadow_engine.py -v
```

Expected: All passing + 4 new node tests

**Step 6: Run full Python suite**

```bash
cd astro-service && pytest -v
```

**Step 7: Commit**

```bash
git add astro-service/shadow_engine.py astro-service/prompt_manager.py astro-service/test_shadow_engine.py
git commit -m "feat(shadow): add Lunar Node karmic triggers (Sun/Moon/Venus/Mars Ã— South/North Node, 3Â° orb)"
```

---

## Task 9: Wire planet_degrees + v2 fields through run/route.ts

`USER_MATCH_FIELDS` ç›®å‰åªæœ‰åŸºç¤æ˜Ÿåº§æ¬„ä½ã€‚éœ€è¦åŠ å…¥ `planet_degrees` JSONBï¼ˆå…§å«æ‰€æœ‰åº¦æ•¸ï¼‰ä»¥åŠ v2 matching æ‰€éœ€çš„å…¶ä»–æ¬„ä½ï¼Œæ‰èƒ½è®“ Tasks 2-4 çš„åº¦æ•¸å‡ç´šåœ¨ç”Ÿç”¢é…å°ä¸­å¯¦éš›ç”Ÿæ•ˆã€‚

**Files:**
- Modify: `destiny-app/src/app/api/matches/run/route.ts`

**Step 1: Update USER_MATCH_FIELDS**

```typescript
const USER_MATCH_FIELDS = [
  'id', 'data_tier',
  // Core signs
  'sun_sign', 'moon_sign', 'venus_sign', 'mars_sign', 'saturn_sign', 'ascendant_sign',
  // BaZi
  'bazi_element', 'bazi_month_branch', 'bazi_day_branch',
  // RPV
  'rpv_conflict', 'rpv_power', 'rpv_energy',
  // Phase G extended signs
  'mercury_sign', 'jupiter_sign', 'pluto_sign', 'chiron_sign', 'juno_sign',
  'house4_sign', 'house8_sign',
  // Phase G psychology
  'attachment_style', 'emotional_capacity',
  // Phase I degrees (JSONB blob â€” spread into flat fields before passing to compute-match)
  'planet_degrees',
  // Algorithm v1.8 nodes
  'north_node_sign', 'south_node_sign',
  // ZWDS prerequisites
  'birth_date', 'gender',
].join(', ')
```

**Step 2: Update UserProfile interface**

```typescript
interface UserProfile {
  id: string
  data_tier: number
  sun_sign: string | null
  moon_sign: string | null
  venus_sign: string | null
  mars_sign: string | null
  saturn_sign: string | null
  ascendant_sign: string | null
  bazi_element: string | null
  bazi_month_branch: string | null
  bazi_day_branch: string | null
  rpv_conflict: string | null
  rpv_power: string | null
  rpv_energy: string | null
  mercury_sign: string | null
  jupiter_sign: string | null
  pluto_sign: string | null
  chiron_sign: string | null
  juno_sign: string | null
  house4_sign: string | null
  house8_sign: string | null
  attachment_style: string | null
  emotional_capacity: number | null
  planet_degrees: Record<string, number | null> | null
  north_node_sign: string | null
  south_node_sign: string | null
  birth_date: string | null
  gender: string | null
}
```

**Step 3: Update callComputeMatch to spread planet_degrees**

åœ¨ `callComputeMatch` å‡½å¼ä¸­ï¼Œå°‡ userA/userB å±•å¹³å¾Œå†ç™¼é€ï¼š

```typescript
async function callComputeMatch(userA: UserProfile, userB: UserProfile): Promise<MatchResult | null> {
  // Spread planet_degrees JSONB into flat degree fields (e.g., sun_degree, venus_degree, ...)
  // This enables orb-based exact degree aspect scoring in the Python algorithm.
  const flattenUser = (u: UserProfile) => {
    const [year, month, day] = (u.birth_date ?? '').split('-').map(Number)
    return {
      ...u,
      ...(u.planet_degrees ?? {}),
      birth_year:  year  || undefined,
      birth_month: month || undefined,
      birth_day:   day   || undefined,
    }
  }
  try {
    const res = await fetch(`${ASTRO_URL}/compute-match`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ user_a: flattenUser(userA), user_b: flattenUser(userB) }),
    })
    if (!res.ok) return null
    return await res.json()
  } catch {
    return null
  }
}
```

**Step 4: Run JS tests**

```bash
cd destiny-app && npx vitest run
```

Expected: All 91 tests pass

**Step 5: Commit**

```bash
git add destiny-app/src/app/api/matches/run/route.ts
git commit -m "feat(matching): wire planet_degrees + v2 fields through run/route.ts for end-to-end degree accuracy"
```

---

## Task 10: Final verification

**Step 1: Run all Python tests**

```bash
cd astro-service && pytest -v
```

Expected: â‰¥ 395 tests pass (388 base + ~7 new node/shadow tests)

**Step 2: Run all JS tests**

```bash
cd destiny-app && npx vitest run
```

Expected: All 91 tests pass

**Step 3: Manual smoke test via sandbox (optional)**

```bash
# Start astro-service
uvicorn main:app --port 8001

# Test cross-sign conjunction â€” should score high with degree data
curl -s -X POST http://localhost:8001/compute-match \
  -H "Content-Type: application/json" \
  -d '{
    "user_a": {"data_tier":1,"sun_sign":"aries","sun_degree":29.0,"moon_sign":"cancer","moon_degree":90.0,"venus_sign":"gemini","venus_degree":60.0,"mars_sign":"aries","mars_degree":5.0,"saturn_sign":"capricorn","saturn_degree":270.0,"ascendant_sign":"leo","ascendant_degree":120.0,"bazi_element":"wood","rpv_conflict":"argue","rpv_power":"control","rpv_energy":"out"},
    "user_b": {"data_tier":1,"sun_sign":"taurus","sun_degree":31.0,"moon_sign":"cancer","moon_degree":90.0,"venus_sign":"gemini","venus_degree":60.0,"mars_sign":"aries","mars_degree":5.0,"saturn_sign":"capricorn","saturn_degree":270.0,"ascendant_sign":"aries","ascendant_degree":6.0,"bazi_element":"fire","rpv_conflict":"cold_war","rpv_power":"follow","rpv_energy":"home"}
  }' | python -m json.tool
```

Expected: High lust/soul scores due to:
- Cross-sign Sun conjunction (29Â° Aries + 31Â° Taurus = 2Â° apart)
- Mars (5Â°) Ã— ASC (6Â°) conjunction: 1Â° â†’ strong tension hit in lust

**Step 4: Update CLAUDE.md version note**

åœ¨ `CLAUDE.md` çš„ `**Algorithm:** v1.7` é‚£è¡Œæ›´æ–°ç‚ºï¼š
```
**Algorithm:** v1.8 â€” orb-based kernel/glitch scoring; ASC cross-aspects in lust; Lunar Node karmic triggers (3Â° orb, soul_mod Â±20); lust/soul modifier propagation fix; planet_degrees wired end-to-end.
```

**Step 5: Update MVP-PROGRESS.md**

åœ¨ Next Steps æ¸…å–®ä¸­æŠŠ Algorithm Enhancement ä¸‹æ–¹åŠ å…¥ï¼š
```
13. ~~**Algorithm Enhancement (2026-02-23)**~~ â† **Done âœ…**
    (orb-based kernel/glitch; ASC lust cross-aspects; Lunar Node triggers; modifier propagation fix; planet_degrees end-to-end)
```

**Step 6: Final commit**

```bash
git add CLAUDE.md docs/MVP-PROGRESS.md
git commit -m "docs: update CLAUDE.md + MVP-PROGRESS.md for Algorithm v1.8"
```

---

## è®Šæ›´æ‘˜è¦

| Task | æª”æ¡ˆ | é¡å‹ | å½±éŸ¿ |
|------|------|------|------|
| T1 Bug Fix | `matching.py` | Fix | lust/soul é›·é”åœ–ç¾åœ¨åæ˜  shadow modifier |
| T2 Kernel upgrade | `matching.py` | Enhancement | è·¨æ˜Ÿåº§åˆç›¸ä¸å†è¢«èª¤åˆ¤ç‚º semi-sextile |
| T3 Glitch upgrade | `matching.py` | Enhancement | åŒä¸Šï¼Œç”¨æ–¼æ‘©æ“¦å®¹å¿åº¦è¨ˆç®— |
| T4 ASC in Lust | `matching.py` | New feature | ç¬¬ä¸€çœ¼å¸å¼•åŠ›æ•æ‰ï¼ˆTier 1 onlyï¼‰ |
| T5 Chart Nodes | `chart.py` | New feature | æ‰€æœ‰ Tier éƒ½èƒ½è¨ˆç®—å—åŒ—äº¤é» |
| T6 Migration 012 | `migrations/012_*.sql`, `types.ts` | DB | æ–°å¢ 4 å€‹ node æ¬„ä½ |
| T7 Birth-data API | `birth-data/route.ts` | Data wire | ç¯€é»è³‡æ–™å›å¯« DB |
| T8 Node Triggers | `shadow_engine.py`, `prompt_manager.py` | New feature | 16 å€‹æ¥­åŠ›æ¨™ç±¤ + soul_mod Â±20 |
| T9 run/route.ts | `run/route.ts` | Data wire | åº¦æ•¸è³‡æ–™è²«é€šåˆ°ç”Ÿç”¢é…å° |

**æ–°å¢æ¸¬è©¦ï¼š** ~15 å€‹ï¼ˆPython ~10 + JS ~5ï¼‰
**æ–°å¢ DB æ¬„ä½ï¼š** 4 å€‹ï¼ˆ`north_node_sign/degree`, `south_node_sign/degree`ï¼‰
**æ–°å¢ WEIGHTS keysï¼š** 4 å€‹ï¼ˆ`lust_mars_asc_ab/ba`, `lust_venus_asc_ab/ba`ï¼‰
**æ–°å¢ shadow tagsï¼š** 16 å€‹ï¼ˆSun/Moon/Venus/Mars Ã— North/South Node Ã— A/Bï¼‰
**æ–°å¢ zh translationsï¼š** 16 å€‹
