# Matching Algorithm v1.6 — WEIGHTS Dict + Linear Decay + Cross-Aspects

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Upgrade `astro-service/matching.py` with (1) a centralized `WEIGHTS` dict, (2) linear orb decay in `compute_exact_aspect`, and (3) cross-person Mars×Venus synastry aspects in `compute_lust_score`.

**Architecture:** Three surgical changes to a single file (`matching.py`). The `WEIGHTS` dict at the top becomes the single source of truth for all scoring weights. `compute_exact_aspect` gains linear decay so a 1° conjunction scores higher than a 7° conjunction. `compute_lust_score` gains cross-person aspects (`mars_a×venus_b`, `mars_b×venus_a`) as its primary signals, replacing the weaker same-planet comparison.

**Tech Stack:** Python 3.11, pytest (`astro-service/test_matching.py` — 41 tests), no new dependencies.

---

## Background: What's being fixed

### Gap 1 — `compute_exact_aspect` uses flat scores, not linear decay

```python
# CURRENT (wrong): any aspect within orb gets the same score
for center, orb, h_score, t_score in ASPECTS:
    if abs(dist - center) <= orb:
        return h_score   # 1° conjunction == 7° conjunction ← bad

# CORRECT: score decays linearly toward orb edge
strength_ratio = 1.0 - (diff / orb)
final_score = 0.2 + (max_score - 0.2) * strength_ratio
# → 0° conjunction gets 1.0, 7° conjunction gets ~0.30
```

Also: opposition tension score upgrades from 0.85 → 1.0 per spec.

### Gap 2 — `compute_lust_score` missing cross-person aspects

```
CURRENT:  venus_a × venus_b (harmony 0.20)  +  mars_a × mars_b (tension 0.25)
CORRECT:  mars_a × venus_b  (tension 0.30)  +  mars_b × venus_a (tension 0.30)  ← main signal!
          venus_a × venus_b (harmony 0.15)  +  mars_a × mars_b  (harmony 0.15)  ← secondary
          h8_a × mars_b (0.10)  +  h8_b × mars_a (0.10)                         ← taboo
```

### Gap 3 — All weights hardcoded inside functions

Weights like `0.20`, `0.25`, `0.35` are scattered across `compute_lust_score`, `compute_kernel_score`, `compute_tracks`, `compute_power_score`, `compute_glitch_score`. Hard to tune.

---

## Task 1: Add WEIGHTS dict + wire `compute_power_score` and `compute_match_score`

Pure refactor — no logic changes, no score changes. All 41 existing tests must still pass.

**Files:**
- Modify: `astro-service/matching.py` (add WEIGHTS after SIGN_ELEMENT ~line 35; update power_score line ~248; update match_score line ~367)

**Step 1: Insert WEIGHTS dict**

After the `SIGN_ELEMENT` dict (around line 35), add:

```python
# ── WEIGHTS — Centralized weight configuration ─────────────────────────────
# Edit these values to tune scoring without touching function bodies.
WEIGHTS = {
    # ── compute_lust_score ──────────────────────────────────────────────────
    "lust_cross_mars_venus":   0.30,   # mars_a × venus_b  (cross-person, tension) ← primary
    "lust_cross_venus_mars":   0.30,   # mars_b × venus_a  (cross-person, tension) ← primary
    "lust_same_venus":         0.15,   # venus_a × venus_b (same-planet, harmony)
    "lust_same_mars":          0.15,   # mars_a × mars_b   (same-planet, harmony)
    "lust_house8_ab":          0.10,   # h8_a × mars_b     (8th house taboo pull)
    "lust_house8_ba":          0.10,   # h8_b × mars_a
    "lust_karmic":             0.25,   # outer-vs-inner karmic triggers
    "lust_power":              0.30,   # RPV power dynamic
    "lust_bazi_restrict_mult": 1.25,   # × multiplier when BaZi elements clash

    # ── compute_kernel_score ─────────────────────────────────────────────────
    "kernel_t1_sun":           0.20,
    "kernel_t1_moon":          0.25,
    "kernel_t1_venus":         0.25,
    "kernel_t1_asc":           0.15,
    "kernel_t1_bazi":          0.15,
    "kernel_t2_sun":           0.25,
    "kernel_t2_moon":          0.20,
    "kernel_t2_venus":         0.25,
    "kernel_t2_bazi":          0.30,
    "kernel_t3_sun":           0.30,
    "kernel_t3_venus":         0.30,
    "kernel_t3_bazi":          0.40,

    # ── compute_tracks ───────────────────────────────────────────────────────
    "track_friend_mercury":          0.40,
    "track_friend_jupiter":          0.40,
    "track_friend_bazi":             0.20,
    "track_passion_mars":            0.30,
    "track_passion_venus":           0.30,
    "track_passion_extreme":         0.10,
    "track_passion_bazi":            0.30,
    "track_partner_moon":            0.35,
    "track_partner_juno":            0.35,
    "track_partner_bazi":            0.30,
    "track_partner_nojuno_moon":     0.55,  # juno absent: moon gets larger share
    "track_partner_nojuno_bazi":     0.45,
    "track_soul_chiron":             0.40,
    "track_soul_karmic":             0.40,
    "track_soul_useful_god":         0.20,
    "track_soul_nochiron_karmic":    0.60,  # chiron absent: karmic gets larger share
    "track_soul_nochiron_useful_god":0.40,

    # ── compute_power_score (RPV) ────────────────────────────────────────────
    "power_conflict":          0.35,
    "power_power":             0.40,
    "power_energy":            0.25,

    # ── compute_glitch_score ─────────────────────────────────────────────────
    "glitch_mars":             0.25,
    "glitch_saturn":           0.25,
    "glitch_mars_sat_ab":      0.25,
    "glitch_mars_sat_ba":      0.25,

    # ── compute_match_score (v1 top-level) ───────────────────────────────────
    "match_kernel":            0.50,
    "match_power":             0.30,
    "match_glitch":            0.20,
}
```

**Step 2: Update `compute_power_score` return line**

```python
# Before:
return conflict * 0.35 + power * 0.40 + energy * 0.25

# After:
return (conflict * WEIGHTS["power_conflict"] +
        power    * WEIGHTS["power_power"] +
        energy   * WEIGHTS["power_energy"])
```

**Step 3: Update `compute_match_score` (v1) total line**

```python
# Before:
total = kernel * 0.5 + power * 0.3 + glitch * 0.2

# After:
total = (kernel * WEIGHTS["match_kernel"] +
         power  * WEIGHTS["match_power"] +
         glitch * WEIGHTS["match_glitch"])
```

**Step 4: Run tests — must all pass (pure refactor)**

```bash
cd astro-service && pytest test_matching.py -v
```

Expected: **41/41 pass** — no logic changed.

**Step 5: Commit**

```bash
git add astro-service/matching.py
git commit -m "refactor: add centralized WEIGHTS dict, wire power_score and match_score"
```

---

## Task 2: Upgrade `compute_exact_aspect` with linear decay

**Files:**
- Modify: `astro-service/matching.py` (`compute_exact_aspect` body, ~lines 117-144)
- Modify: `astro-service/test_matching.py` (add 3 new tests; fix any broken existing tests)

**Context for the implementer:** The function currently returns the same flat score for any aspect within orb. For example, a 1° conjunction and a 7° conjunction both return `harmony=1.0`. The new formula makes the score decay linearly from the aspect center:

```
diff = abs(dist - center_deg)
strength_ratio = 1.0 - (diff / orb)      # 1.0 at center, 0.0 at orb edge
final_score = 0.2 + (max_score - 0.2) * strength_ratio
```

So a 0° conjunction: `strength=1.0 → score=1.0`.
A 7° conjunction: `strength=(1-7/8)=0.125 → score=0.2+(1.0-0.2)*0.125=0.30`.

Also fix: opposition `tension_max` changes from 0.85 → 1.0 (spec correction).

**Step 1: Add 3 failing tests to `test_matching.py`**

```python
def test_exact_aspect_linear_decay_conjunction():
    """Closer conjunction must score higher than wider conjunction."""
    score_1deg    = compute_exact_aspect(0.0, 1.0,  "harmony")
    score_7deg    = compute_exact_aspect(0.0, 7.0,  "harmony")
    score_perfect = compute_exact_aspect(0.0, 0.0,  "harmony")
    assert score_1deg > score_7deg, f"{score_1deg} should > {score_7deg}"
    assert score_perfect == pytest.approx(1.0, abs=0.01)


def test_exact_aspect_linear_decay_square_tension():
    """Square at center (90°) scores higher than square near orb edge."""
    score_center = compute_exact_aspect(0.0, 90.0, "tension")   # diff=0
    score_edge   = compute_exact_aspect(0.0, 97.5, "tension")   # diff=7.5° within orb 8
    assert score_center > score_edge
    assert score_center >= 0.88  # near max 0.9


def test_exact_aspect_opposition_tension_max():
    """Opposition in tension mode should return 1.0 (not 0.85)."""
    score = compute_exact_aspect(0.0, 180.0, "tension")
    assert score == pytest.approx(1.0, abs=0.01)
```

**Step 2: Run to verify they fail**

```bash
cd astro-service && pytest test_matching.py::test_exact_aspect_linear_decay_conjunction test_matching.py::test_exact_aspect_linear_decay_square_tension test_matching.py::test_exact_aspect_opposition_tension_max -v
```

Expected: **3 FAIL**.

**Step 3: Replace `compute_exact_aspect` body**

```python
def compute_exact_aspect(deg_a: float, deg_b: float, mode: str = "harmony") -> float:
    """Orb-based exact degree aspect score with linear decay (0.0-1.0).

    Score decays linearly from the aspect center toward the orb boundary:
      strength_ratio = 1.0 - (diff / orb)
      final_score    = 0.2 + (max_score - 0.2) * strength_ratio

    Aspect table (center_deg, orb, harmony_max, tension_max):
      conjunction  (0°,   orb 8°): harmony=1.0  tension=1.0
      sextile     (60°,  orb 6°): harmony=0.8  tension=0.3
      square      (90°,  orb 8°): harmony=0.2  tension=0.9
      trine      (120°,  orb 8°): harmony=1.0  tension=0.2
      opposition (180°,  orb 8°): harmony=0.4  tension=1.0

    Returns 0.5 (neutral) when either degree is None.
    Returns 0.1 (void of aspect) when no major aspect is within orb.
    """
    if deg_a is None or deg_b is None:
        return 0.5
    dist = get_shortest_distance(deg_a, deg_b)
    ASPECT_RULES = [
        (0,   8,  1.0, 1.0),
        (60,  6,  0.8, 0.3),
        (90,  8,  0.2, 0.9),
        (120, 8,  1.0, 0.2),
        (180, 8,  0.4, 1.0),
    ]
    for center, orb, harm_max, tens_max in ASPECT_RULES:
        diff = abs(dist - center)
        if diff <= orb:
            max_score = harm_max if mode == "harmony" else tens_max
            strength_ratio = 1.0 - (diff / orb)
            return round(0.2 + (max_score - 0.2) * strength_ratio, 2)
    return 0.1  # void of aspect
```

**Step 4: Run the 3 new tests — must pass**

```bash
cd astro-service && pytest test_matching.py::test_exact_aspect_linear_decay_conjunction test_matching.py::test_exact_aspect_linear_decay_square_tension test_matching.py::test_exact_aspect_opposition_tension_max -v
```

Expected: **3 PASS**.

**Step 5: Run full suite and fix any broken existing tests**

```bash
cd astro-service && pytest test_matching.py -v 2>&1 | head -80
```

The linear decay changes scores. Any test that hard-coded a flat score (e.g., `assert score == 0.9`) for `compute_exact_aspect` will now fail. For each failing test:

1. Calculate the expected new score using the formula: `0.2 + (max_score - 0.2) * (1.0 - diff/orb)` where `diff = abs(get_shortest_distance(deg_a, deg_b) - center)`.
2. Update the assertion. Prefer `pytest.approx(expected, abs=0.01)` for float comparisons.

Example:
```python
# Old: assert compute_exact_aspect(0.0, 90.0, "tension") == 0.9
# New: assert compute_exact_aspect(0.0, 90.0, "tension") == pytest.approx(0.9, abs=0.01)
# (0° from center → strength=1.0 → 0.2 + (0.9-0.2)*1.0 = 0.9 ✓ unchanged at center)

# Old: assert compute_exact_aspect(0.0, 5.0, "harmony") == 1.0   ← was flat
# New: assert compute_exact_aspect(0.0, 5.0, "harmony") == pytest.approx(0.58, abs=0.01)
# (5° from 0° center, orb=8 → strength=(1-5/8)=0.375 → 0.2+(1.0-0.2)*0.375=0.50 → rounds to 0.50)
```

Run `pytest test_matching.py -v` again until all pass.

**Step 6: Commit**

```bash
git add astro-service/matching.py astro-service/test_matching.py
git commit -m "feat: upgrade compute_exact_aspect with linear orb decay, fix opposition tension to 1.0"
```

---

## Task 3: Rewrite `compute_lust_score` with cross-person aspects

**Files:**
- Modify: `astro-service/matching.py` (`compute_lust_score`, ~lines 433-485)
- Modify: `astro-service/test_matching.py` (2 new tests; fix any broken existing tests)

**Context:** The new function reads `venus_degree`, `mars_degree`, `house8_degree` directly from user dicts (same pattern as `compute_karmic_triggers` which reads `uranus_degree`, `moon_degree`, etc. directly). Falls back to sign-level comparison when exact degrees are absent.

**Step 1: Add 2 failing tests**

```python
def test_lust_cross_aspects_opposition_gives_high_score():
    """mars_a exactly opposite venus_b → high lust (tension mode opposition = 1.0)."""
    user_a = {
        "mars_degree": 0.0,   "mars_sign": "aries",
        "venus_degree": None, "venus_sign": "aries",
        "bazi_element": "wood",
        "rpv_power": "control", "rpv_conflict": "cold_war", "rpv_energy": "out",
    }
    user_b = {
        "venus_degree": 180.0, "venus_sign": "libra",
        "mars_degree": None,   "mars_sign": "libra",
        "bazi_element": "water",
        "rpv_power": "follow", "rpv_conflict": "argue", "rpv_energy": "home",
    }
    score = compute_lust_score(user_a, user_b)
    assert score >= 65.0, f"Mars opposite Venus should give high lust, got {score}"


def test_lust_cross_beats_same_planet():
    """Cross-aspect pair (mars_a × venus_b opposition) scores higher than same-planet trine pair."""
    # Pair A: mars_a (0°) opposite venus_b (180°) — cross tension
    cross_a = {
        "mars_degree": 0.0,    "mars_sign": "aries",
        "venus_degree": None,  "venus_sign": "aries",
        "rpv_power": "control", "rpv_conflict": "cold_war", "rpv_energy": "out",
    }
    cross_b = {
        "venus_degree": 180.0, "venus_sign": "libra",
        "mars_degree": None,   "mars_sign": "libra",
        "rpv_power": "follow", "rpv_conflict": "argue", "rpv_energy": "home",
    }
    # Pair B: venus_a (0°) trine venus_b (120°) — same-planet harmony
    same_a = {
        "venus_degree": 0.0,   "venus_sign": "aries",
        "mars_degree": None,   "mars_sign": "aries",
        "rpv_power": "control", "rpv_conflict": "cold_war", "rpv_energy": "out",
    }
    same_b = {
        "venus_degree": 120.0, "venus_sign": "leo",
        "mars_degree": None,   "mars_sign": "leo",
        "rpv_power": "follow", "rpv_conflict": "argue", "rpv_energy": "home",
    }
    cross_score = compute_lust_score(cross_a, cross_b)
    same_score  = compute_lust_score(same_a,  same_b)
    assert cross_score > same_score, f"Cross {cross_score:.1f} should > same-planet {same_score:.1f}"
```

**Step 2: Run to verify they fail**

```bash
cd astro-service && pytest test_matching.py::test_lust_cross_aspects_opposition_gives_high_score test_matching.py::test_lust_cross_beats_same_planet -v
```

Expected: **2 FAIL**.

**Step 3: Replace `compute_lust_score` body**

```python
def compute_lust_score(user_a: dict, user_b: dict) -> float:
    """Lust Score (X axis): physical/desire attraction (0-100).

    Primary signal — cross-person Mars × Venus aspects (exact degrees → sign fallback):
      mars_a × venus_b  tension × WEIGHTS["lust_cross_mars_venus"]  (0.30) ← main driver
      mars_b × venus_a  tension × WEIGHTS["lust_cross_venus_mars"]  (0.30)

    Secondary — same-planet harmony:
      venus_a × venus_b harmony × WEIGHTS["lust_same_venus"]  (0.15)
      mars_a × mars_b   harmony × WEIGHTS["lust_same_mars"]   (0.15)

    Taboo pull — 8th house × Mars (exact degrees only; omitted when absent):
      h8_a × mars_b  tension × WEIGHTS["lust_house8_ab"]  (0.10)
      h8_b × mars_a  tension × WEIGHTS["lust_house8_ba"]  (0.10)

    Karmic: outer-vs-inner triggers × WEIGHTS["lust_karmic"]  (0.25)
    Power:  RPV dynamic              × WEIGHTS["lust_power"]   (0.30)

    Multiplier: × WEIGHTS["lust_bazi_restrict_mult"] (1.25) when BaZi elements clash.
    """
    score = 0.0
    total_weight = 0.0

    def _aspect(deg_x, sign_x, deg_y, sign_y, mode):
        """Use exact degrees if both available; fall back to sign-level."""
        if deg_x is not None and deg_y is not None:
            return compute_exact_aspect(deg_x, deg_y, mode)
        return compute_sign_aspect(sign_x, sign_y, mode)

    venus_a_deg  = user_a.get("venus_degree")
    venus_b_deg  = user_b.get("venus_degree")
    mars_a_deg   = user_a.get("mars_degree")
    mars_b_deg   = user_b.get("mars_degree")
    h8_a_deg     = user_a.get("house8_degree")
    h8_b_deg     = user_b.get("house8_degree")

    # 1. Cross-person: mars_a × venus_b (A pursues B)
    w = WEIGHTS["lust_cross_mars_venus"]
    score += _aspect(mars_a_deg, user_a.get("mars_sign"),
                     venus_b_deg, user_b.get("venus_sign"), "tension") * w
    total_weight += w

    # 2. Cross-person: mars_b × venus_a (B pursues A)
    w = WEIGHTS["lust_cross_venus_mars"]
    score += _aspect(mars_b_deg, user_b.get("mars_sign"),
                     venus_a_deg, user_a.get("venus_sign"), "tension") * w
    total_weight += w

    # 3. Same-planet: venus_a × venus_b (aesthetic sync)
    w = WEIGHTS["lust_same_venus"]
    score += _aspect(venus_a_deg, user_a.get("venus_sign"),
                     venus_b_deg, user_b.get("venus_sign"), "harmony") * w
    total_weight += w

    # 4. Same-planet: mars_a × mars_b (energy rhythm sync)
    w = WEIGHTS["lust_same_mars"]
    score += _aspect(mars_a_deg, user_a.get("mars_sign"),
                     mars_b_deg, user_b.get("mars_sign"), "harmony") * w
    total_weight += w

    # 5. House 8 × Mars cross-aspects (exact degrees only; omitted from denominator if absent)
    if h8_a_deg is not None and mars_b_deg is not None:
        w = WEIGHTS["lust_house8_ab"]
        score += compute_exact_aspect(h8_a_deg, mars_b_deg, "tension") * w
        total_weight += w
    if h8_b_deg is not None and mars_a_deg is not None:
        w = WEIGHTS["lust_house8_ba"]
        score += compute_exact_aspect(h8_b_deg, mars_a_deg, "tension") * w
        total_weight += w

    # 6. Karmic triggers (outer vs inner planets)
    karmic = compute_karmic_triggers(user_a, user_b)
    w = WEIGHTS["lust_karmic"]
    score += karmic * w
    total_weight += w

    # 7. RPV power dynamic
    power_val = compute_power_score(user_a, user_b)
    w = WEIGHTS["lust_power"]
    score += power_val * w
    total_weight += w

    base_score = score / total_weight if total_weight > 0 else NEUTRAL_SIGNAL

    # BaZi restriction multiplier (clash = fatal attraction / conquest desire)
    elem_a = user_a.get("bazi_element")
    elem_b = user_b.get("bazi_element")
    if elem_a and elem_b:
        rel = analyze_element_relation(elem_a, elem_b)
        if rel["relation"] in ("a_restricts_b", "b_restricts_a"):
            base_score *= WEIGHTS["lust_bazi_restrict_mult"]

    return _clamp(base_score * 100)
```

**Step 4: Run the 2 new tests — must pass**

```bash
cd astro-service && pytest test_matching.py::test_lust_cross_aspects_opposition_gives_high_score test_matching.py::test_lust_cross_beats_same_planet -v
```

Expected: **2 PASS**.

**Step 5: Run full suite and fix regressions**

```bash
cd astro-service && pytest test_matching.py -v
```

Some existing lust tests may have expected values that no longer hold (different formula). Update them:
- If a test expected a specific score like `== 65.0`, change to a range check `>= 55.0` or recalculate the expected value using the new formula.
- Do NOT delete tests — update them to reflect the corrected logic.

**Step 6: Commit**

```bash
git add astro-service/matching.py astro-service/test_matching.py
git commit -m "feat: add cross-person Mars×Venus aspects to compute_lust_score (v1.6)"
```

---

## Task 4: Wire WEIGHTS into remaining functions

Pure refactor — no score changes. Affects: `compute_kernel_score`, `compute_glitch_score`, `compute_tracks`.

**Files:**
- Modify: `astro-service/matching.py` (three functions)

**Step 1: Update `compute_kernel_score`**

Replace the three `return` statements:

```python
if effective_tier == 1:
    return (sun   * WEIGHTS["kernel_t1_sun"]   +
            moon  * WEIGHTS["kernel_t1_moon"]  +
            venus * WEIGHTS["kernel_t1_venus"] +
            asc   * WEIGHTS["kernel_t1_asc"]   +
            bazi  * WEIGHTS["kernel_t1_bazi"])
elif effective_tier == 2:
    return (sun   * WEIGHTS["kernel_t2_sun"]   +
            moon  * WEIGHTS["kernel_t2_moon"]  +
            venus * WEIGHTS["kernel_t2_venus"] +
            bazi  * WEIGHTS["kernel_t2_bazi"])
else:
    return (sun   * WEIGHTS["kernel_t3_sun"]   +
            venus * WEIGHTS["kernel_t3_venus"] +
            bazi  * WEIGHTS["kernel_t3_bazi"])
```

**Step 2: Update `compute_glitch_score`**

Replace return statement:
```python
return (mars        * WEIGHTS["glitch_mars"] +
        saturn      * WEIGHTS["glitch_saturn"] +
        mars_sat_ab * WEIGHTS["glitch_mars_sat_ab"] +
        mars_sat_ba * WEIGHTS["glitch_mars_sat_ba"])
```

**Step 3: Update `compute_tracks`**

Replace the friend/passion/partner/soul calculations:

```python
friend = (
    WEIGHTS["track_friend_mercury"] * mercury +
    WEIGHTS["track_friend_jupiter"] * jupiter +
    WEIGHTS["track_friend_bazi"]    * (1.0 if bazi_harmony else 0.0)
)
passion = (
    WEIGHTS["track_passion_mars"]    * mars +
    WEIGHTS["track_passion_venus"]   * venus +
    WEIGHTS["track_passion_extreme"] * passion_extremity +
    WEIGHTS["track_passion_bazi"]    * (1.0 if bazi_clash else 0.0)
)
if juno_present:
    partner = (
        moon * WEIGHTS["track_partner_moon"] +
        juno * WEIGHTS["track_partner_juno"] +
        (1.0 if bazi_generation else 0.0) * WEIGHTS["track_partner_bazi"]
    )
else:
    partner = (
        moon * WEIGHTS["track_partner_nojuno_moon"] +
        (1.0 if bazi_generation else 0.0) * WEIGHTS["track_partner_nojuno_bazi"]
    )

if chiron_present:
    soul_track = (
        chiron               * WEIGHTS["track_soul_chiron"] +
        karmic               * WEIGHTS["track_soul_karmic"] +
        useful_god_complement * WEIGHTS["track_soul_useful_god"]
    )
else:
    soul_track = (
        karmic               * WEIGHTS["track_soul_nochiron_karmic"] +
        useful_god_complement * WEIGHTS["track_soul_nochiron_useful_god"]
    )
```

**Step 4: Run full test suite — all must pass**

```bash
cd astro-service && pytest test_matching.py -v
```

Expected: **All tests pass** (pure refactor, numeric values identical to previous WEIGHTS dict values).

**Step 5: Commit**

```bash
git add astro-service/matching.py
git commit -m "refactor: wire WEIGHTS dict into kernel, glitch, and tracks functions"
```

---

## Verification

After all 4 tasks complete:

```bash
cd astro-service && pytest test_matching.py -v --tb=short
```

Expected: All tests pass. Confirm the final test count is ≥ 41 (new tests added in Tasks 2 and 3).

Check the WEIGHTS dict is the only place with raw floating point weights:
```bash
grep -n "0\.30\|0\.25\|0\.40\|0\.35" astro-service/matching.py | grep -v "WEIGHTS\|#\|def \|docstring"
```

This should return zero lines (all literals replaced by WEIGHTS references).
